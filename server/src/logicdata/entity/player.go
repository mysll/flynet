// Code generated by data parser.
// DO NOT EDIT!
package entity

import (
	"bytes"
	"encoding/gob"
	"encoding/json"
	"fmt"
	. "logicdata/inter"
	"math"
	. "server/data/datatype"
	"server/libs/log"
	"server/util"
)

//邮箱行定义
type PlayerMailBoxRow struct {
	Source_uid  uint64 `json:"1"` //发件人UID
	Source_name string `json:"2"` //发件人名称
	SendTime    int64  `json:"3"` //发件时间
	Title       string `json:"4"` //标题
	Content     string `json:"5"` //内容
	Appendix    string `json:"6"` //附件
	IsRead      int8   `json:"7"` //是否已读
	Serial_no   uint64 `json:"8"` //邮件序列号
	MsgType     int32  `json:"9"` //邮件类型
}

//邮箱
type PlayerMailBox struct {
	MaxRows int `json:"-"`
	Cols    int `json:"-"`
	Rows    []PlayerMailBoxRow
	Dirty   bool `json:"-"`
	syncer  TableSyncer
	owner   *Player
}

//已承接任务表行定义
type PlayerTaskAcceptedRow struct {
	ID   string `json:"1"` //任务编号
	Flag int8   `json:"2"` //任务标记
}

//已承接任务表
type PlayerTaskAccepted struct {
	MaxRows int `json:"-"`
	Cols    int `json:"-"`
	Rows    []PlayerTaskAcceptedRow
	Dirty   bool `json:"-"`
	syncer  TableSyncer
	owner   *Player
}

//任务记录表行定义
type PlayerTaskRecordRow struct {
	ID            string `json:"1"` //任务编号
	Typ           int32  `json:"2"` //记录类型
	Key           string `json:"3"` //关键字ID(如物品编号、NPC编号等等)
	CurrentAmount int32  `json:"4"` //当前完成度
	TotalAmount   int32  `json:"5"` //总进度
	Flag          int8   `json:"6"` //任务标记
}

//任务记录表
type PlayerTaskRecord struct {
	MaxRows int `json:"-"`
	Cols    int `json:"-"`
	Rows    []PlayerTaskRecordRow
	Dirty   bool `json:"-"`
	syncer  TableSyncer
	owner   *Player
}

//可承接任务表行定义
type PlayerTaskCanAcceptRow struct {
	ID string `json:"1"` //任务编号
}

//可承接任务表
type PlayerTaskCanAccept struct {
	MaxRows int `json:"-"`
	Cols    int `json:"-"`
	Rows    []PlayerTaskCanAcceptRow
	Dirty   bool `json:"-"`
	syncer  TableSyncer
	owner   *Player
}

//任务时间限制记录表行定义
type PlayerTaskTimeLimitRow struct {
	ID        string `json:"1"` //任务编号
	StartTime int64  `json:"2"` //开始时间记录
	EndTime   int64  `json:"3"` //结束时间记录
}

//任务时间限制记录表
type PlayerTaskTimeLimit struct {
	MaxRows int `json:"-"`
	Cols    int `json:"-"`
	Rows    []PlayerTaskTimeLimitRow
	Dirty   bool `json:"-"`
	syncer  TableSyncer
	owner   *Player
}

//任务全局记录表行定义
type PlayerTaskGlobalRecordRow struct {
	Typ           int32  `json:"1"` //记录类型
	Key           string `json:"2"` //关键字ID(如物品编号、NPC编号等等)
	CurrentAmount int32  `json:"3"` //当前完成度
}

//任务全局记录表
type PlayerTaskGlobalRecord struct {
	MaxRows int `json:"-"`
	Cols    int `json:"-"`
	Rows    []PlayerTaskGlobalRecordRow
	Dirty   bool `json:"-"`
	syncer  TableSyncer
	owner   *Player
}

//任务属性记录表行定义
type PlayerTaskPropRecordRow struct {
	ID        string `json:"1"` //任务编号
	Property  string `json:"2"` //属性名
	NeedValue string `json:"3"` //属性达成条件
}

//任务属性记录表
type PlayerTaskPropRecord struct {
	MaxRows int `json:"-"`
	Cols    int `json:"-"`
	Rows    []PlayerTaskPropRecordRow
	Dirty   bool `json:"-"`
	syncer  TableSyncer
	owner   *Player
}

type Player_Save_Property struct {
	Capacity       int32  `json:"C"` //容量
	ConfigId       string `json:"I"`
	DataVer        int32  //数据版本号
	Name           string //名称
	Sex            int8   //性别
	Level          int16  //等级
	Model          int32  //模型
	Exp            int32  //经验
	Vip            int8   //VIP等级
	MaxExp         int32  //经验上限
	HP             int32  //血
	MP             int32  //魔
	MaxHP          int32  //血上限
	MaxMP          int32  //魔上限
	LastUpdateTime int64  //最后刷新时间
}

//保存到DB的数据
type Player_Save struct {
	Player_Save_Property

	MailBox_r          PlayerMailBox
	TaskAccepted_r     PlayerTaskAccepted
	TaskRecord_r       PlayerTaskRecord
	TaskCanAccept_r    PlayerTaskCanAccept
	TaskTimeLimit_r    PlayerTaskTimeLimit
	TaskGlobalRecord_r PlayerTaskGlobalRecord
	TaskPropRecord_r   PlayerTaskPropRecord
}

func (s *Player_Save) Base() string {

	return ""

}

func (s *Player_Save) Marshal() (map[string]interface{}, error) {
	data, err := json.Marshal(*s)
	if err != nil {
		return nil, err
	}

	var ret map[string]interface{}
	err = json.Unmarshal(data, &ret)
	return ret, err
}

func (s *Player_Save) Unmarshal(data map[string]interface{}) error {
	d, err := json.Marshal(data)
	if err != nil {
		return err
	}

	err = json.Unmarshal(d, s)

	return err
}

func (s *Player_Save) InsertOrUpdate(eq ExecQueryer, insert bool, dbId uint64, extfields string, extplacehold string, extobjs ...interface{}) error {
	var sql string
	var args []interface{}
	if insert {
		sql = "INSERT INTO `tbl_player`(`id`,`capacity`,`configid`,`p_dataver`,`p_name`,`p_sex`,`p_level`,`p_model`,`p_exp`,`p_vip`,`p_maxexp`,`p_hp`,`p_mp`,`p_maxhp`,`p_maxmp`,`p_lastupdatetime`%s ) VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?%s) "
		args = []interface{}{dbId, s.Capacity, s.ConfigId, s.DataVer, s.Name, s.Sex, s.Level, s.Model, s.Exp, s.Vip, s.MaxExp, s.HP, s.MP, s.MaxHP, s.MaxMP, s.LastUpdateTime}
		sql = fmt.Sprintf(sql, extfields, extplacehold)
		if extobjs != nil {
			args = append(args, extobjs...)
		}
	} else {
		sql = "UPDATE `tbl_player` SET %s`capacity`=?, `configid`=?,`p_dataver`=?,`p_name`=?,`p_sex`=?,`p_level`=?,`p_model`=?,`p_exp`=?,`p_vip`=?,`p_maxexp`=?,`p_hp`=?,`p_mp`=?,`p_maxhp`=?,`p_maxmp`=?,`p_lastupdatetime`=? WHERE `id` = ?"
		if extobjs != nil {
			args = append(args, extobjs...)
		}
		args = append(args, []interface{}{s.Capacity, s.ConfigId, s.DataVer, s.Name, s.Sex, s.Level, s.Model, s.Exp, s.Vip, s.MaxExp, s.HP, s.MP, s.MaxHP, s.MaxMP, s.LastUpdateTime, dbId}...)
		sql = fmt.Sprintf(sql, extfields)

	}

	if _, err := eq.Exec(sql, args...); err != nil {
		log.LogError("InsertOrUpdate error:", sql, args)
		return err
	}

	return nil
}

func (s *Player_Save) Update(eq ExecQueryer, dbId uint64, extfields string, extplacehold string, extobjs ...interface{}) (err error) {
	if err = s.InsertOrUpdate(eq, false, dbId, extfields, extplacehold, extobjs...); err != nil {
		return
	}

	if err = s.MailBox_r.Update(eq, dbId); err != nil {
		return
	}

	if err = s.TaskAccepted_r.Update(eq, dbId); err != nil {
		return
	}

	if err = s.TaskRecord_r.Update(eq, dbId); err != nil {
		return
	}

	if err = s.TaskCanAccept_r.Update(eq, dbId); err != nil {
		return
	}

	if err = s.TaskTimeLimit_r.Update(eq, dbId); err != nil {
		return
	}

	if err = s.TaskGlobalRecord_r.Update(eq, dbId); err != nil {
		return
	}

	if err = s.TaskPropRecord_r.Update(eq, dbId); err != nil {
		return
	}

	return
}

func (s *Player_Save) Insert(eq ExecQueryer, dbId uint64, extfields string, extplacehold string, extobjs ...interface{}) (err error) {
	if err = s.InsertOrUpdate(eq, true, dbId, extfields, extplacehold, extobjs...); err != nil {
		return
	}

	if err = s.MailBox_r.Update(eq, dbId); err != nil {
		return
	}

	if err = s.TaskAccepted_r.Update(eq, dbId); err != nil {
		return
	}

	if err = s.TaskRecord_r.Update(eq, dbId); err != nil {
		return
	}

	if err = s.TaskCanAccept_r.Update(eq, dbId); err != nil {
		return
	}

	if err = s.TaskTimeLimit_r.Update(eq, dbId); err != nil {
		return
	}

	if err = s.TaskGlobalRecord_r.Update(eq, dbId); err != nil {
		return
	}

	if err = s.TaskPropRecord_r.Update(eq, dbId); err != nil {
		return
	}

	return
}

func (s *Player_Save) Query(dbId uint64) (sql string, args []interface{}) {
	sql = "SELECT `id`,`capacity`,`configid`,`p_dataver`,`p_name`,`p_sex`,`p_level`,`p_model`,`p_exp`,`p_vip`,`p_maxexp`,`p_hp`,`p_mp`,`p_maxhp`,`p_maxmp`,`p_lastupdatetime` %s FROM `tbl_player` WHERE `id`=? LIMIT 1"
	args = []interface{}{dbId}
	return
}

func (s *Player_Save) Load(eq ExecQueryer, dbId uint64, extfield string, extobjs ...interface{}) error {
	sql, a := s.Query(dbId)
	sql = fmt.Sprintf(sql, extfield)
	r, err := eq.Query(sql, a...)
	if err != nil {
		log.LogError("load error:", err)
		return err
	}
	defer r.Close()
	if !r.Next() {
		log.LogError("load error:", sql, a)
		return ErrSqlRowError
	}
	args := []interface{}{&dbId, &s.Capacity, &s.ConfigId, &s.DataVer, &s.Name, &s.Sex, &s.Level, &s.Model, &s.Exp, &s.Vip, &s.MaxExp, &s.HP, &s.MP, &s.MaxHP, &s.MaxMP, &s.LastUpdateTime}
	if extobjs != nil {
		args = append(args, extobjs...)
	}
	if err = r.Scan(args...); err != nil {
		log.LogError("load error:", err)
		return err
	}

	if err = s.MailBox_r.Load(eq, dbId); err != nil {
		log.LogError("load error:", err)
		return err
	}
	if err = s.TaskAccepted_r.Load(eq, dbId); err != nil {
		log.LogError("load error:", err)
		return err
	}
	if err = s.TaskRecord_r.Load(eq, dbId); err != nil {
		log.LogError("load error:", err)
		return err
	}
	if err = s.TaskCanAccept_r.Load(eq, dbId); err != nil {
		log.LogError("load error:", err)
		return err
	}
	if err = s.TaskTimeLimit_r.Load(eq, dbId); err != nil {
		log.LogError("load error:", err)
		return err
	}
	if err = s.TaskGlobalRecord_r.Load(eq, dbId); err != nil {
		log.LogError("load error:", err)
		return err
	}
	if err = s.TaskPropRecord_r.Load(eq, dbId); err != nil {
		log.LogError("load error:", err)
		return err
	}

	return nil
}

type Player_Propertys struct {
	//属性定义

}

type Player_t struct {
	dirty           bool
	ObjectType      int
	DbId            uint64
	parent          Entity
	ObjId           ObjectID
	Deleted         bool
	NameHash        int32
	IDHash          int32
	ContainerInited bool
	Index           int //在容器中的位置
	Childs          []Entity
	ChildNum        int

	Save bool //是否保存
}

type Player struct {
	*Moveable
	*AOI

	uid          uint64 //全局ID
	InScene      bool   //是否在场景中
	InBase       bool   //是否在base中
	Mdirty       map[string]interface{}
	Mmodify      map[string]interface{}
	ExtraData    map[string]interface{}
	loading      bool
	quiting      bool
	propsyncer   PropSyncer
	prophooker   PropHooker
	propcritical []uint64
	propflag     []uint64

	Player_t
	Player_Save
	Player_Propertys

	//表格定义
}

func (obj *Player) SetUID(v uint64) {
	obj.uid = v
}

func (obj *Player) UID() uint64 {
	return obj.uid
}

func (obj *Player) SetInBase(v bool) {
	obj.InBase = v
}

func (obj *Player) IsInBase() bool {
	return obj.InBase
}

func (obj *Player) SetInScene(v bool) {
	obj.InScene = v
}

func (obj *Player) IsInScene() bool {
	return obj.InScene
}

func (obj *Player) SetLoading(loading bool) {
	obj.loading = loading
}

func (obj *Player) IsLoading() bool {
	return obj.loading
}

func (obj *Player) SetQuiting() {
	obj.quiting = true
}

func (obj *Player) IsQuiting() bool {
	return obj.quiting
}

func (obj *Player) GetConfig() string {
	return obj.ConfigId
}

func (obj *Player) SetConfig(config string) {
	obj.ConfigId = config
	obj.IDHash = Hash(config)
}

func (obj *Player) SetSaveFlag() {
	root := obj.GetRoot()
	if root != nil {
		root.SetSaveFlag()
	} else {
		obj.dirty = true
	}
}

func (obj *Player) ClearSaveFlag() {
	obj.dirty = false

	obj.MailBox_r.Dirty = false
	obj.TaskAccepted_r.Dirty = false
	obj.TaskRecord_r.Dirty = false
	obj.TaskCanAccept_r.Dirty = false
	obj.TaskTimeLimit_r.Dirty = false
	obj.TaskGlobalRecord_r.Dirty = false
	obj.TaskPropRecord_r.Dirty = false
}

func (obj *Player) NeedSave() bool {
	if obj.dirty || obj.MailBox_r.Dirty || obj.TaskAccepted_r.Dirty || obj.TaskRecord_r.Dirty || obj.TaskCanAccept_r.Dirty || obj.TaskTimeLimit_r.Dirty || obj.TaskGlobalRecord_r.Dirty || obj.TaskPropRecord_r.Dirty {
		return true
	}
	return false
}

func (obj *Player) ChangeCapacity(capacity int32) error {

	if !obj.ContainerInited {
		return ErrContainerNotInit
	}

	if capacity == -1 || capacity == obj.Capacity {
		return ErrContainerCapacity
	}

	if capacity < int32(obj.ChildCount()) {
		return ErrContainerCapacity
	}

	newchilds := make([]Entity, capacity)
	if capacity < obj.Capacity { //缩容，位置将进行重排
		idx := 0
		for _, c := range obj.Childs {
			if c != nil {
				c.SetIndex(idx)
				newchilds[idx] = c
				idx++
			}
		}
	} else { //扩容，直接进行复制
		for k, c := range obj.Childs {
			newchilds[k] = c
		}
	}

	obj.ContainerInited = true
	obj.Capacity = capacity
	obj.Childs = newchilds
	return nil
}

//设置子对象的存储容量，-1为无限，无限时，需要提供初始容量。
func (obj *Player) SetCapacity(capacity int32, initcap int32) {

	if obj.ContainerInited {
		return
	}

	if capacity == -1 {
		obj.Childs = make([]Entity, 0, initcap)
	} else if capacity > 0 {
		obj.Childs = make([]Entity, capacity)
	} else {
		obj.Childs = nil
	}
	obj.Capacity = capacity
	obj.ContainerInited = true

}

func (obj *Player) GetCapacity() int32 {
	return obj.Capacity
}

//获取实际的容量
func (obj *Player) GetRealCap() int32 {
	if !obj.ContainerInited {
		return 0
	}
	return int32(len(obj.Childs))
}

func (obj *Player) GetRoot() Entity {
	var ent Entity
	if obj.GetParent() == nil {
		return nil
	}
	ent = obj
	for {
		if ent.GetParent() == nil {
			break
		}
		if ent.GetParent().ObjType() == SCENE {
			break
		}
		ent = ent.GetParent()
	}
	return ent
}

//获取数据库id
func (obj *Player) GetDbId() uint64 {
	return obj.DbId
}

func (obj *Player) SetDbId(id uint64) {
	obj.DbId = id
}

func (obj *Player) SetParent(p Entity) {
	obj.parent = p
}

func (obj *Player) GetParent() Entity {
	return obj.parent
}

func (obj *Player) SetDeleted(d bool) {
	obj.Deleted = d
}

func (obj *Player) GetDeleted() bool {
	return obj.Deleted
}

func (obj *Player) SetObjId(id ObjectID) {
	obj.ObjId = id
}

func (obj *Player) GetObjId() ObjectID {
	return obj.ObjId
}

//设置名字Hash
func (obj *Player) SetNameHash(v int32) {
	obj.NameHash = v
}

//获取名字Hash
func (obj *Player) GetNameHash() int32 {
	return obj.NameHash
}

//名字比较
func (obj *Player) NameEqual(name string) bool {
	return obj.Name == name
}

//获取IDHash
func (obj *Player) GetIDHash() int32 {
	return obj.IDHash
}

//ID比较
func (obj *Player) IDEqual(id string) bool {
	return obj.ConfigId == id
}

func (obj *Player) ChildCount() int {
	return obj.ChildNum
}

//移除对象
func (obj *Player) RemoveChild(de Entity) error {
	idx := de.GetIndex()
	e := obj.GetChild(idx)

	if e != nil && e.GetObjId().Equal(de.GetObjId()) {
		obj.Childs[idx] = nil
		de.SetParent(nil)
		obj.ChildNum--
		return nil
	}

	return ErrChildObjectNotFound
}

//获取子对象
func (obj *Player) GetChilds() []Entity {
	return obj.Childs
}

//获取容器中索引
func (obj *Player) GetIndex() int {
	return obj.Index
}

//设置索引，逻辑层不要调用
func (obj *Player) SetIndex(idx int) {
	obj.Index = idx
}

//删除所有的子对象
func (obj *Player) ClearChilds() {
	for _, c := range obj.Childs {
		if c != nil {
			obj.RemoveChild(c)
		}
	}

	if obj.Capacity == -1 {
		obj.Childs = obj.Childs[:0]
	}
	obj.ChildNum = 0
}

//增加子对象
func (obj *Player) AddChild(idx int, e Entity) (index int, err error) {
	if !obj.ContainerInited {
		err = ErrContainerNotInit
		return
	}
	if obj.Capacity == -1 {
		for i, v := range obj.Childs {
			if v == nil {
				obj.Childs[i] = e
				e.SetIndex(i)
				e.SetParent(obj)
				obj.ChildNum++
				index = e.GetIndex()
				return
			}
		}
		obj.Childs = append(obj.Childs, e)
		e.SetIndex(len(obj.Childs) - 1)
		e.SetParent(obj)
		index = e.GetIndex()
		obj.ChildNum++
		return
	}

	if idx == -1 {
		for i, v := range obj.Childs {
			if v == nil {
				idx = i
				break
			}
		}
		if idx == -1 {
			err = ErrContainerFull
			return
		}
	}

	if idx >= len(obj.Childs) {
		log.LogError("out of range, ", idx, ",", len(obj.Childs))
		err = ErrContainerIndexOutOfRange
		return
	}

	if obj.Childs[idx] != nil {
		err = ErrContainerIndexHasChild
		return
	}

	obj.Childs[idx] = e
	e.SetIndex(idx)
	e.SetParent(obj)
	obj.ChildNum++
	index = e.GetIndex()
	return

}

//获取子对象
func (obj *Player) GetChild(idx int) Entity {
	if !obj.ContainerInited {
		return nil
	}
	if idx < 0 || idx >= len(obj.Childs) {
		return nil
	}
	return obj.Childs[idx]
}

//通过ID获取子对象
func (obj *Player) GetChildByConfigId(id string) Entity {
	if !obj.ContainerInited {
		return nil
	}
	h := Hash(id)
	for _, v := range obj.Childs {
		if (v != nil) && (v.GetIDHash() == h) && v.IDEqual(id) {
			return v
		}
	}
	return nil
}
func (obj *Player) GetFirstChildByConfigId(id string) (int, Entity) {
	if !obj.ContainerInited {
		return -1, nil
	}
	h := Hash(id)
	for k, v := range obj.Childs {
		if (v != nil) && (v.GetIDHash() == h) && v.IDEqual(id) {
			return k + 1, v
		}
	}
	return -1, nil
}
func (obj *Player) GetNextChildByConfigId(start int, id string) (int, Entity) {

	if !obj.ContainerInited || start == -1 || start >= len(obj.Childs) {
		return -1, nil
	}
	h := Hash(id)
	for k, v := range obj.Childs[start:] {
		if (v != nil) && (v.GetIDHash() == h) && v.IDEqual(id) {
			return start + k + 1, v
		}
	}
	return -1, nil
}

//通过名称获取子对象
func (obj *Player) GetChildByName(name string) Entity {
	if !obj.ContainerInited {
		return nil
	}
	h := Hash(name)
	for _, v := range obj.Childs {
		if (v != nil) && (v.GetNameHash() == h) && v.NameEqual(name) {
			return v
		}
	}
	return nil
}
func (obj *Player) GetFirstChild(name string) (int, Entity) {
	if !obj.ContainerInited {
		return -1, nil
	}
	h := Hash(name)
	for k, v := range obj.Childs {
		if (v != nil) && (v.GetNameHash() == h) && v.NameEqual(name) {
			return k + 1, v
		}
	}
	return -1, nil
}
func (obj *Player) GetNextChild(start int, name string) (int, Entity) {

	if !obj.ContainerInited || start == -1 || start >= len(obj.Childs) {
		return -1, nil
	}
	h := Hash(name)
	for k, v := range obj.Childs[start:] {
		if (v != nil) && (v.GetNameHash() == h) && v.NameEqual(name) {
			return start + k + 1, v
		}
	}
	return -1, nil
}

//交换子对象的位置
func (obj *Player) SwapChild(src int, dest int) error {
	if !obj.ContainerInited {
		return ErrContainerNotInit
	}
	if src < 0 || src >= len(obj.Childs) || dest < 0 || dest >= len(obj.Childs) {
		return ErrContainerIndexOutOfRange
	}

	obj.Childs[src], obj.Childs[dest] = obj.Childs[dest], obj.Childs[src]
	if obj.Childs[src] != nil {
		obj.Childs[src].SetIndex(src)
	}
	if obj.Childs[dest] != nil {
		obj.Childs[dest].SetIndex(dest)
	}
	return nil
}

//获取基类
func (obj *Player) Base() Entity {
	return nil
}

//获取对象类型
func (obj *Player) ObjType() int {
	return obj.ObjectType
}

//额外的数据
func (obj *Player) SetExtraData(key string, value interface{}) {
	obj.ExtraData[key] = value
}

func (obj *Player) GetExtraData(key string) interface{} {
	if v, ok := obj.ExtraData[key]; ok {
		return v
	}
	return nil
}

func (obj *Player) GetAllExtraData() map[string]interface{} {
	return obj.ExtraData
}

func (obj *Player) RemoveExtraData(key string) {
	if _, ok := obj.ExtraData[key]; ok {
		delete(obj.ExtraData, key)
	}
}

func (obj *Player) ClearExtraData() {
	for k := range obj.ExtraData {
		delete(obj.ExtraData, k)
	}
}

//获取对象是否保存
func (obj *Player) IsSave() bool {
	return obj.Save
}

//设置对象是否保存
func (obj *Player) SetSave(s bool) {
	obj.Save = s
}

//获取对象类型名
func (obj *Player) ObjTypeName() string {
	return "Player"
}

func (obj *Player) SetPropSyncer(sync PropSyncer) {
	obj.propsyncer = sync
}

func (obj *Player) GetPropSyncer() PropSyncer {
	return obj.propsyncer
}

//属性回调接口
func (obj *Player) SetPropHooker(hooker PropHooker) {
	obj.prophooker = hooker
}

func (obj *Player) GetPropFlag(idx int) bool {
	index := idx / 64
	bit := uint(idx) % 64
	return obj.propflag[index]&(uint64(1)<<bit) != 0
}

func (obj *Player) SetPropFlag(idx int, flag bool) {
	index := idx / 64
	bit := uint(idx) % 64
	if flag {
		obj.propflag[index] = obj.propflag[index] | (uint64(1) << bit)
		return
	}
	obj.propflag[index] = obj.propflag[index] & ^(uint64(1) << bit)
}

func (obj *Player) IsCritical(idx int) bool {
	index := idx / 64
	bit := uint(idx) % 64
	return obj.propcritical[index]&(uint64(1)<<bit) != 0
}

func (obj *Player) SetCritical(prop string) {
	idx, err := obj.GetPropertyIndex(prop)
	if err != nil {
		return
	}

	index := int(idx) / 64
	bit := uint(idx) % 64

	obj.propcritical[index] = obj.propcritical[index] | (uint64(1) << bit)
}

func (obj *Player) ClearCritical(prop string) {
	idx, err := obj.GetPropertyIndex(prop)
	if err != nil {
		return
	}

	index := int(idx) / 64
	bit := uint(idx) % 64

	obj.propcritical[index] = obj.propcritical[index] & ^(uint64(1) << bit)
}

//获取所有属性
func (obj *Player) GetPropertys() []string {
	return []string{
		"DataVer",
		"Name",
		"Sex",
		"Level",
		"Model",
		"Exp",
		"Vip",
		"MaxExp",
		"HP",
		"MP",
		"MaxHP",
		"MaxMP",
		"LastUpdateTime",
	}
}

//获取所有可视属性
func (obj *Player) GetVisiblePropertys(typ int) []string {
	if typ == 0 {
		return []string{
			"Name",
			"Sex",
			"Level",
			"Model",
			"Exp",
			"Vip",
			"MaxExp",
			"HP",
			"MP",
			"MaxHP",
			"MaxMP",
		}
	} else {
		return []string{}
	}

}

//获取属性类型
func (obj *Player) GetPropertyType(p string) (int, string, error) {
	switch p {
	case "DataVer":
		return DT_INT32, "int32", nil
	case "Name":
		return DT_STRING, "string", nil
	case "Sex":
		return DT_INT8, "int8", nil
	case "Level":
		return DT_INT16, "int16", nil
	case "Model":
		return DT_INT32, "int32", nil
	case "Exp":
		return DT_INT32, "int32", nil
	case "Vip":
		return DT_INT8, "int8", nil
	case "MaxExp":
		return DT_INT32, "int32", nil
	case "HP":
		return DT_INT32, "int32", nil
	case "MP":
		return DT_INT32, "int32", nil
	case "MaxHP":
		return DT_INT32, "int32", nil
	case "MaxMP":
		return DT_INT32, "int32", nil
	case "LastUpdateTime":
		return DT_INT64, "int64", nil
	default:
		return DT_NONE, "", ErrPropertyNotFound
	}
}

//通过属性名设置值
func (obj *Player) GetPropertyIndex(p string) (int, error) {
	switch p {
	case "DataVer":
		return 0, nil
	case "Name":
		return 1, nil
	case "Sex":
		return 2, nil
	case "Level":
		return 3, nil
	case "Model":
		return 4, nil
	case "Exp":
		return 5, nil
	case "Vip":
		return 6, nil
	case "MaxExp":
		return 7, nil
	case "HP":
		return 8, nil
	case "MP":
		return 9, nil
	case "MaxHP":
		return 10, nil
	case "MaxMP":
		return 11, nil
	case "LastUpdateTime":
		return 12, nil
	default:
		return -1, ErrPropertyNotFound
	}
}

//通过属性名设置值
func (obj *Player) Inc(p string, v interface{}) error {
	switch p {
	case "DataVer":
		var dst int32
		err := ParseNumber(v, &dst)
		if err == nil {
			obj.IncDataVer(dst)
		}
		return err
	case "Sex":
		var dst int8
		err := ParseNumber(v, &dst)
		if err == nil {
			obj.IncSex(dst)
		}
		return err
	case "Level":
		var dst int16
		err := ParseNumber(v, &dst)
		if err == nil {
			obj.IncLevel(dst)
		}
		return err
	case "Model":
		var dst int32
		err := ParseNumber(v, &dst)
		if err == nil {
			obj.IncModel(dst)
		}
		return err
	case "Exp":
		var dst int32
		err := ParseNumber(v, &dst)
		if err == nil {
			obj.IncExp(dst)
		}
		return err
	case "Vip":
		var dst int8
		err := ParseNumber(v, &dst)
		if err == nil {
			obj.IncVip(dst)
		}
		return err
	case "MaxExp":
		var dst int32
		err := ParseNumber(v, &dst)
		if err == nil {
			obj.IncMaxExp(dst)
		}
		return err
	case "HP":
		var dst int32
		err := ParseNumber(v, &dst)
		if err == nil {
			obj.IncHP(dst)
		}
		return err
	case "MP":
		var dst int32
		err := ParseNumber(v, &dst)
		if err == nil {
			obj.IncMP(dst)
		}
		return err
	case "MaxHP":
		var dst int32
		err := ParseNumber(v, &dst)
		if err == nil {
			obj.IncMaxHP(dst)
		}
		return err
	case "MaxMP":
		var dst int32
		err := ParseNumber(v, &dst)
		if err == nil {
			obj.IncMaxMP(dst)
		}
		return err
	case "LastUpdateTime":
		var dst int64
		err := ParseNumber(v, &dst)
		if err == nil {
			obj.IncLastUpdateTime(dst)
		}
		return err
	default:
		return ErrPropertyNotFound
	}
	return nil
}

//通过属性名设置值
func (obj *Player) Set(p string, v interface{}) error {
	switch p {
	case "DataVer":
		var dst int32
		err := ParseNumber(v, &dst)
		if err == nil {
			obj.SetDataVer(dst)
		}
		return err
	case "Name":
		val, ok := v.(string)
		if ok {
			obj.SetName(val)
		} else {
			return ErrTypeMismatch
		}
	case "Sex":
		var dst int8
		err := ParseNumber(v, &dst)
		if err == nil {
			obj.SetSex(dst)
		}
		return err
	case "Level":
		var dst int16
		err := ParseNumber(v, &dst)
		if err == nil {
			obj.SetLevel(dst)
		}
		return err
	case "Model":
		var dst int32
		err := ParseNumber(v, &dst)
		if err == nil {
			obj.SetModel(dst)
		}
		return err
	case "Exp":
		var dst int32
		err := ParseNumber(v, &dst)
		if err == nil {
			obj.SetExp(dst)
		}
		return err
	case "Vip":
		var dst int8
		err := ParseNumber(v, &dst)
		if err == nil {
			obj.SetVip(dst)
		}
		return err
	case "MaxExp":
		var dst int32
		err := ParseNumber(v, &dst)
		if err == nil {
			obj.SetMaxExp(dst)
		}
		return err
	case "HP":
		var dst int32
		err := ParseNumber(v, &dst)
		if err == nil {
			obj.SetHP(dst)
		}
		return err
	case "MP":
		var dst int32
		err := ParseNumber(v, &dst)
		if err == nil {
			obj.SetMP(dst)
		}
		return err
	case "MaxHP":
		var dst int32
		err := ParseNumber(v, &dst)
		if err == nil {
			obj.SetMaxHP(dst)
		}
		return err
	case "MaxMP":
		var dst int32
		err := ParseNumber(v, &dst)
		if err == nil {
			obj.SetMaxMP(dst)
		}
		return err
	case "LastUpdateTime":
		var dst int64
		err := ParseNumber(v, &dst)
		if err == nil {
			obj.SetLastUpdateTime(dst)
		}
		return err
	default:
		return ErrPropertyNotFound
	}
	return nil
}

//通过属性索引设置值
func (obj *Player) SetByIndex(index int16, v interface{}) error {
	switch index {
	case 0:
		var dst int32
		err := ParseNumber(v, &dst)
		if err == nil {
			obj.SetDataVer(dst)
		}
		return err
	case 1:
		val, ok := v.(string)
		if ok {
			obj.SetName(val)
		} else {
			return ErrTypeMismatch
		}
	case 2:
		var dst int8
		err := ParseNumber(v, &dst)
		if err == nil {
			obj.SetSex(dst)
		}
		return err
	case 3:
		var dst int16
		err := ParseNumber(v, &dst)
		if err == nil {
			obj.SetLevel(dst)
		}
		return err
	case 4:
		var dst int32
		err := ParseNumber(v, &dst)
		if err == nil {
			obj.SetModel(dst)
		}
		return err
	case 5:
		var dst int32
		err := ParseNumber(v, &dst)
		if err == nil {
			obj.SetExp(dst)
		}
		return err
	case 6:
		var dst int8
		err := ParseNumber(v, &dst)
		if err == nil {
			obj.SetVip(dst)
		}
		return err
	case 7:
		var dst int32
		err := ParseNumber(v, &dst)
		if err == nil {
			obj.SetMaxExp(dst)
		}
		return err
	case 8:
		var dst int32
		err := ParseNumber(v, &dst)
		if err == nil {
			obj.SetHP(dst)
		}
		return err
	case 9:
		var dst int32
		err := ParseNumber(v, &dst)
		if err == nil {
			obj.SetMP(dst)
		}
		return err
	case 10:
		var dst int32
		err := ParseNumber(v, &dst)
		if err == nil {
			obj.SetMaxHP(dst)
		}
		return err
	case 11:
		var dst int32
		err := ParseNumber(v, &dst)
		if err == nil {
			obj.SetMaxMP(dst)
		}
		return err
	case 12:
		var dst int64
		err := ParseNumber(v, &dst)
		if err == nil {
			obj.SetLastUpdateTime(dst)
		}
		return err
	default:
		return ErrPropertyNotFound
	}
	return nil
}

//通过属性名获取值
func (obj *Player) MustGet(p string) interface{} {
	switch p {
	case "DataVer":
		return obj.DataVer
	case "Name":
		return obj.Name
	case "Sex":
		return obj.Sex
	case "Level":
		return obj.Level
	case "Model":
		return obj.Model
	case "Exp":
		return obj.Exp
	case "Vip":
		return obj.Vip
	case "MaxExp":
		return obj.MaxExp
	case "HP":
		return obj.HP
	case "MP":
		return obj.MP
	case "MaxHP":
		return obj.MaxHP
	case "MaxMP":
		return obj.MaxMP
	case "LastUpdateTime":
		return obj.LastUpdateTime
	default:
		return nil
	}
}

//通过属性名获取值
func (obj *Player) Get(p string) (val interface{}, err error) {
	switch p {
	case "DataVer":
		return obj.DataVer, nil
	case "Name":
		return obj.Name, nil
	case "Sex":
		return obj.Sex, nil
	case "Level":
		return obj.Level, nil
	case "Model":
		return obj.Model, nil
	case "Exp":
		return obj.Exp, nil
	case "Vip":
		return obj.Vip, nil
	case "MaxExp":
		return obj.MaxExp, nil
	case "HP":
		return obj.HP, nil
	case "MP":
		return obj.MP, nil
	case "MaxHP":
		return obj.MaxHP, nil
	case "MaxMP":
		return obj.MaxMP, nil
	case "LastUpdateTime":
		return obj.LastUpdateTime, nil
	default:
		return nil, ErrPropertyNotFound
	}
}

//是否需要同步到其它客户端
func (obj *Player) PropertyIsPublic(p string) bool {
	switch p {
	case "DataVer":
		return false
	case "Name":
		return false
	case "Sex":
		return false
	case "Level":
		return false
	case "Model":
		return false
	case "Exp":
		return false
	case "Vip":
		return false
	case "MaxExp":
		return false
	case "HP":
		return false
	case "MP":
		return false
	case "MaxHP":
		return false
	case "MaxMP":
		return false
	case "LastUpdateTime":
		return false
	default:
		return false
	}
}

//是否需要同步到自己的客户端
func (obj *Player) PropertyIsPrivate(p string) bool {
	switch p {
	case "DataVer":
		return false
	case "Name":
		return true
	case "Sex":
		return true
	case "Level":
		return true
	case "Model":
		return true
	case "Exp":
		return true
	case "Vip":
		return true
	case "MaxExp":
		return true
	case "HP":
		return true
	case "MP":
		return true
	case "MaxHP":
		return true
	case "MaxMP":
		return true
	case "LastUpdateTime":
		return false
	default:
		return false
	}
}

//是否需要存档
func (obj *Player) PropertyIsSave(p string) bool {
	switch p {
	case "DataVer":
		return true
	case "Name":
		return true
	case "Sex":
		return true
	case "Level":
		return true
	case "Model":
		return true
	case "Exp":
		return true
	case "Vip":
		return true
	case "MaxExp":
		return true
	case "HP":
		return true
	case "MP":
		return true
	case "MaxHP":
		return true
	case "MaxMP":
		return true
	case "LastUpdateTime":
		return true
	default:
		return false
	}
}

//脏标志(数据保存用)
func (obj *Player) setDirty(p string, v interface{}) {
	//obj.Mdirty[p] = v
	obj.SetSaveFlag()
}

func (obj *Player) GetDirty() map[string]interface{} {

	return obj.Mdirty
}

func (obj *Player) ClearDirty() {
	for k := range obj.Mdirty {
		delete(obj.Mdirty, k)
	}
}

//修改标志(数据同步用)
func (obj *Player) setModify(p string, v interface{}) {
	obj.Mmodify[p] = v
}

func (obj *Player) GetModify() map[string]interface{} {
	return obj.Mmodify
}

func (obj *Player) ClearModify() {
	for k := range obj.Mmodify {
		delete(obj.Mmodify, k)
	}
}

//数据版本号
func (obj *Player) SetDataVer(v int32) {
	if obj.DataVer == v {
		return
	}

	old := obj.DataVer

	if !obj.InBase { //只有base能够修改自身的数据
		log.LogError("can't change base data")
	}

	obj.DataVer = v
	if obj.prophooker != nil && obj.IsCritical(0) && !obj.GetPropFlag(0) {
		obj.SetPropFlag(0, true)
		obj.prophooker.OnPropChange(obj, "DataVer", old)
		obj.SetPropFlag(0, false)
	}

	obj.setDirty("DataVer", v)
}
func (obj *Player) GetDataVer() int32 {
	return obj.DataVer
}
func (obj *Player) IncDataVer(v int32) {
	obj.SetDataVer(obj.DataVer + v)
}

//名称
func (obj *Player) SetName(v string) {
	if obj.Name == v {
		return
	}

	old := obj.Name

	if !obj.InBase { //只有base能够修改自身的数据
		log.LogError("can't change base data")
	}

	obj.Name = v
	if obj.prophooker != nil && obj.IsCritical(1) && !obj.GetPropFlag(1) {
		obj.SetPropFlag(1, true)
		obj.prophooker.OnPropChange(obj, "Name", old)
		obj.SetPropFlag(1, false)
	}
	obj.NameHash = Hash(v)
	obj.setModify("Name", v)

	obj.setDirty("Name", v)
}
func (obj *Player) GetName() string {
	return obj.Name
}

//性别
func (obj *Player) SetSex(v int8) {
	if obj.Sex == v {
		return
	}

	old := obj.Sex

	if !obj.InBase { //只有base能够修改自身的数据
		log.LogError("can't change base data")
	}

	obj.Sex = v
	if obj.prophooker != nil && obj.IsCritical(2) && !obj.GetPropFlag(2) {
		obj.SetPropFlag(2, true)
		obj.prophooker.OnPropChange(obj, "Sex", old)
		obj.SetPropFlag(2, false)
	}
	obj.setModify("Sex", v)

	obj.setDirty("Sex", v)
}
func (obj *Player) GetSex() int8 {
	return obj.Sex
}
func (obj *Player) IncSex(v int8) {
	obj.SetSex(obj.Sex + v)
}

//等级
func (obj *Player) SetLevel(v int16) {
	if obj.Level == v {
		return
	}

	old := obj.Level

	if !obj.InBase { //只有base能够修改自身的数据
		log.LogError("can't change base data")
	}

	obj.Level = v
	if obj.prophooker != nil && obj.IsCritical(3) && !obj.GetPropFlag(3) {
		obj.SetPropFlag(3, true)
		obj.prophooker.OnPropChange(obj, "Level", old)
		obj.SetPropFlag(3, false)
	}
	obj.setModify("Level", v)

	obj.setDirty("Level", v)
}
func (obj *Player) GetLevel() int16 {
	return obj.Level
}
func (obj *Player) IncLevel(v int16) {
	obj.SetLevel(obj.Level + v)
}

//模型
func (obj *Player) SetModel(v int32) {
	if obj.Model == v {
		return
	}

	old := obj.Model

	if !obj.InBase { //只有base能够修改自身的数据
		log.LogError("can't change base data")
	}

	obj.Model = v
	if obj.prophooker != nil && obj.IsCritical(4) && !obj.GetPropFlag(4) {
		obj.SetPropFlag(4, true)
		obj.prophooker.OnPropChange(obj, "Model", old)
		obj.SetPropFlag(4, false)
	}
	obj.setModify("Model", v)

	obj.setDirty("Model", v)
}
func (obj *Player) GetModel() int32 {
	return obj.Model
}
func (obj *Player) IncModel(v int32) {
	obj.SetModel(obj.Model + v)
}

//经验
func (obj *Player) SetExp(v int32) {
	if obj.Exp == v {
		return
	}

	old := obj.Exp

	if !obj.InBase { //只有base能够修改自身的数据
		log.LogError("can't change base data")
	}

	obj.Exp = v
	if obj.prophooker != nil && obj.IsCritical(5) && !obj.GetPropFlag(5) {
		obj.SetPropFlag(5, true)
		obj.prophooker.OnPropChange(obj, "Exp", old)
		obj.SetPropFlag(5, false)
	}
	obj.setModify("Exp", v)

	obj.setDirty("Exp", v)
}
func (obj *Player) GetExp() int32 {
	return obj.Exp
}
func (obj *Player) IncExp(v int32) {
	obj.SetExp(obj.Exp + v)
}

//VIP等级
func (obj *Player) SetVip(v int8) {
	if obj.Vip == v {
		return
	}

	old := obj.Vip

	if !obj.InBase { //只有base能够修改自身的数据
		log.LogError("can't change base data")
	}

	obj.Vip = v
	if obj.prophooker != nil && obj.IsCritical(6) && !obj.GetPropFlag(6) {
		obj.SetPropFlag(6, true)
		obj.prophooker.OnPropChange(obj, "Vip", old)
		obj.SetPropFlag(6, false)
	}
	obj.setModify("Vip", v)

	obj.setDirty("Vip", v)
}
func (obj *Player) GetVip() int8 {
	return obj.Vip
}
func (obj *Player) IncVip(v int8) {
	obj.SetVip(obj.Vip + v)
}

//经验上限
func (obj *Player) SetMaxExp(v int32) {
	if obj.MaxExp == v {
		return
	}

	old := obj.MaxExp

	if !obj.InBase { //只有base能够修改自身的数据
		log.LogError("can't change base data")
	}

	obj.MaxExp = v
	if obj.prophooker != nil && obj.IsCritical(7) && !obj.GetPropFlag(7) {
		obj.SetPropFlag(7, true)
		obj.prophooker.OnPropChange(obj, "MaxExp", old)
		obj.SetPropFlag(7, false)
	}
	obj.setModify("MaxExp", v)

	obj.setDirty("MaxExp", v)
}
func (obj *Player) GetMaxExp() int32 {
	return obj.MaxExp
}
func (obj *Player) IncMaxExp(v int32) {
	obj.SetMaxExp(obj.MaxExp + v)
}

//血
func (obj *Player) SetHP(v int32) {
	if obj.HP == v {
		return
	}

	old := obj.HP

	if obj.InBase && obj.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the data will be overwritten by scenedata")
	}

	obj.HP = v
	if obj.prophooker != nil && obj.IsCritical(8) && !obj.GetPropFlag(8) {
		obj.SetPropFlag(8, true)
		obj.prophooker.OnPropChange(obj, "HP", old)
		obj.SetPropFlag(8, false)
	}
	obj.setModify("HP", v)

	obj.setDirty("HP", v)
}
func (obj *Player) GetHP() int32 {
	return obj.HP
}
func (obj *Player) IncHP(v int32) {
	obj.SetHP(obj.HP + v)
}

//魔
func (obj *Player) SetMP(v int32) {
	if obj.MP == v {
		return
	}

	old := obj.MP

	if obj.InBase && obj.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the data will be overwritten by scenedata")
	}

	obj.MP = v
	if obj.prophooker != nil && obj.IsCritical(9) && !obj.GetPropFlag(9) {
		obj.SetPropFlag(9, true)
		obj.prophooker.OnPropChange(obj, "MP", old)
		obj.SetPropFlag(9, false)
	}
	obj.setModify("MP", v)

	obj.setDirty("MP", v)
}
func (obj *Player) GetMP() int32 {
	return obj.MP
}
func (obj *Player) IncMP(v int32) {
	obj.SetMP(obj.MP + v)
}

//血上限
func (obj *Player) SetMaxHP(v int32) {
	if obj.MaxHP == v {
		return
	}

	old := obj.MaxHP

	if !obj.InBase { //只有base能够修改自身的数据
		log.LogError("can't change base data")
	}

	obj.MaxHP = v
	if obj.prophooker != nil && obj.IsCritical(10) && !obj.GetPropFlag(10) {
		obj.SetPropFlag(10, true)
		obj.prophooker.OnPropChange(obj, "MaxHP", old)
		obj.SetPropFlag(10, false)
	}
	obj.setModify("MaxHP", v)

	obj.setDirty("MaxHP", v)
}
func (obj *Player) GetMaxHP() int32 {
	return obj.MaxHP
}
func (obj *Player) IncMaxHP(v int32) {
	obj.SetMaxHP(obj.MaxHP + v)
}

//魔上限
func (obj *Player) SetMaxMP(v int32) {
	if obj.MaxMP == v {
		return
	}

	old := obj.MaxMP

	if !obj.InBase { //只有base能够修改自身的数据
		log.LogError("can't change base data")
	}

	obj.MaxMP = v
	if obj.prophooker != nil && obj.IsCritical(11) && !obj.GetPropFlag(11) {
		obj.SetPropFlag(11, true)
		obj.prophooker.OnPropChange(obj, "MaxMP", old)
		obj.SetPropFlag(11, false)
	}
	obj.setModify("MaxMP", v)

	obj.setDirty("MaxMP", v)
}
func (obj *Player) GetMaxMP() int32 {
	return obj.MaxMP
}
func (obj *Player) IncMaxMP(v int32) {
	obj.SetMaxMP(obj.MaxMP + v)
}

//最后刷新时间
func (obj *Player) SetLastUpdateTime(v int64) {
	if obj.LastUpdateTime == v {
		return
	}

	old := obj.LastUpdateTime

	if !obj.InBase { //只有base能够修改自身的数据
		log.LogError("can't change base data")
	}

	obj.LastUpdateTime = v
	if obj.prophooker != nil && obj.IsCritical(12) && !obj.GetPropFlag(12) {
		obj.SetPropFlag(12, true)
		obj.prophooker.OnPropChange(obj, "LastUpdateTime", old)
		obj.SetPropFlag(12, false)
	}

	obj.setDirty("LastUpdateTime", v)
}
func (obj *Player) GetLastUpdateTime() int64 {
	return obj.LastUpdateTime
}
func (obj *Player) IncLastUpdateTime(v int64) {
	obj.SetLastUpdateTime(obj.LastUpdateTime + v)
}

func (rec *PlayerMailBox) Marshal() ([]byte, error) {
	return json.Marshal(rec)
}

func (rec *PlayerMailBox) Unmarshal(data []byte) error {
	return json.Unmarshal(data, rec)
}

//DB
func (rec *PlayerMailBox) Update(eq ExecQueryer, dbId uint64) error {

	if !rec.Dirty {
		return nil
	}

	data, err := rec.Marshal()
	if err != nil {
		return err
	}
	sql := "UPDATE `tbl_player` SET `r_mailbox`=? WHERE `id` = ?"

	if _, err := eq.Exec(sql, data, dbId); err != nil {
		log.LogError("update record PlayerMailBox error:", sql, data, dbId)
		return err
	}

	return nil
}

func (rec *PlayerMailBox) Load(eq ExecQueryer, dbId uint64) error {

	rec.Rows = rec.Rows[:0]

	sql := "SELECT `r_mailbox` FROM `tbl_player` WHERE `id`=? LIMIT 1"
	r, err := eq.Query(sql, dbId)
	if err != nil {
		log.LogError("load record PlayerMailBox error:", err)
		return err
	}
	defer r.Close()
	if !r.Next() {
		log.LogError("load record PlayerMailBox error:", sql, dbId)
		return ErrSqlRowError
	}
	var json []byte
	if err = r.Scan(&json); err != nil {
		log.LogError("load record PlayerMailBox error:", err)
		return err
	}

	if json == nil || len(json) < 2 {
		log.LogWarning("load record PlayerMailBox error: nil")
		return nil
	}

	err = rec.Unmarshal(json)
	if err != nil {
		log.LogError("unmarshal record PlayerMailBox error:", err)
		return err
	}

	return nil
}

func (rec *PlayerMailBox) GetName() string {
	return "MailBox"
}

//表格的容量
func (rec *PlayerMailBox) GetCap() int {
	return rec.MaxRows
}

//表格当前的行数
func (rec *PlayerMailBox) GetRows() int {
	return len(rec.Rows)
}

//获取列定义
func (rec *PlayerMailBox) ColTypes() ([]int, []string) {
	col := []int{DT_UINT64, DT_STRING, DT_INT64, DT_STRING, DT_STRING, DT_STRING, DT_INT8, DT_UINT64, DT_INT32}
	cols := []string{"uint64", "string", "int64", "string", "string", "string", "int8", "uint64", "int32"}
	return col, cols
}

//获取列数
func (rec *PlayerMailBox) GetCols() int {
	return rec.Cols
}

//是否要同步到客户端
func (rec *PlayerMailBox) IsVisible() bool {
	return true
}

//脏标志
func (rec *PlayerMailBox) IsDirty() bool {
	return rec.Dirty
}

func (rec *PlayerMailBox) ClearDirty() {
	rec.Dirty = false
}

func (rec *PlayerMailBox) SetSyncer(s TableSyncer) {
	rec.syncer = s
}

func (rec *PlayerMailBox) GetSyncer() TableSyncer {
	return rec.syncer
}

//序列化
func (rec *PlayerMailBox) Serial() ([]byte, error) {
	ar := util.NewStoreArchiver(nil)
	for _, v := range rec.Rows {
		ar.Write(v.Source_uid)
		ar.WriteString(v.Source_name)
		ar.Write(v.SendTime)
		ar.WriteString(v.Title)
		ar.WriteString(v.Content)
		ar.WriteString(v.Appendix)
		ar.Write(v.IsRead)
		ar.Write(v.Serial_no)
		ar.Write(v.MsgType)
	}
	return ar.Data(), nil
}

//序列化一行
func (rec *PlayerMailBox) SerialRow(row int) ([]byte, error) {
	if row < 0 || row >= len(rec.Rows) {
		return nil, ErrRowError
	}
	ar := util.NewStoreArchiver(nil)
	v := rec.Rows[row]
	ar.Write(v.Source_uid)
	ar.WriteString(v.Source_name)
	ar.Write(v.SendTime)
	ar.WriteString(v.Title)
	ar.WriteString(v.Content)
	ar.WriteString(v.Appendix)
	ar.Write(v.IsRead)
	ar.Write(v.Serial_no)
	ar.Write(v.MsgType)
	return ar.Data(), nil
}

//通过行列设置值
func (rec *PlayerMailBox) Set(row, col int, val interface{}) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the MailBox will be overwritten by scenedata")
	}

	if row < 0 || row >= len(rec.Rows) {
		return ErrRowError
	}

	if col < 0 || col >= 9 {
		return ErrColError
	}

	r := &rec.Rows[row]

	switch col {
	case 0:
		val, ok := val.(uint64)
		if ok {
			r.Source_uid = val
		} else {
			return ErrTypeMismatch
		}
	case 1:
		val, ok := val.(string)
		if ok {
			r.Source_name = val
		} else {
			return ErrTypeMismatch
		}
	case 2:
		val, ok := val.(int64)
		if ok {
			r.SendTime = val
		} else {
			return ErrTypeMismatch
		}
	case 3:
		val, ok := val.(string)
		if ok {
			r.Title = val
		} else {
			return ErrTypeMismatch
		}
	case 4:
		val, ok := val.(string)
		if ok {
			r.Content = val
		} else {
			return ErrTypeMismatch
		}
	case 5:
		val, ok := val.(string)
		if ok {
			r.Appendix = val
		} else {
			return ErrTypeMismatch
		}
	case 6:
		val, ok := val.(int8)
		if ok {
			r.IsRead = val
		} else {
			return ErrTypeMismatch
		}
	case 7:
		val, ok := val.(uint64)
		if ok {
			r.Serial_no = val
		} else {
			return ErrTypeMismatch
		}
	case 8:
		val, ok := val.(int32)
		if ok {
			r.MsgType = val
		} else {
			return ErrTypeMismatch
		}
	}
	if rec.syncer != nil {
		rec.syncer.RecModify(rec.owner, rec, row, col)
	}
	rec.Dirty = true
	return nil
}

//通过行列获取值
func (rec *PlayerMailBox) Get(row, col int) (val interface{}, err error) {
	if row < 0 || row >= len(rec.Rows) {
		err = ErrRowError
		return
	}

	if col < 0 || col >= 9 {
		err = ErrColError
		return
	}

	r := rec.Rows[row]

	switch col {
	case 0:
		val = r.Source_uid
	case 1:
		val = r.Source_name
	case 2:
		val = r.SendTime
	case 3:
		val = r.Title
	case 4:
		val = r.Content
	case 5:
		val = r.Appendix
	case 6:
		val = r.IsRead
	case 7:
		val = r.Serial_no
	case 8:
		val = r.MsgType
	}

	return
}

//查找发件人UID
func (rec *PlayerMailBox) FindSource_uid(v uint64) int {
	for idx, row := range rec.Rows {
		if row.Source_uid == v {
			return idx
		}
	}
	return -1
}

//查找发件人UID
func (rec *PlayerMailBox) FindNextSource_uid(v uint64, itr int) int {
	itr++
	if itr+1 >= len(rec.Rows) {
		return -1
	}
	for idx, row := range rec.Rows[itr:] {
		if row.Source_uid == v {
			return idx
		}
	}
	return -1
}

//设置发件人UID
func (rec *PlayerMailBox) SetSource_uid(row int, v uint64) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the Source_uid will be overwritten by scenedata")
	}

	if row < 0 || row >= len(rec.Rows) {
		return ErrRowError
	}

	rec.Rows[row].Source_uid = v
	rec.Dirty = true
	if rec.syncer != nil {
		rec.syncer.RecModify(rec.owner, rec, row, 0)
	}
	return nil
}

//获取发件人UID
func (rec *PlayerMailBox) GetSource_uid(row int) (val uint64, err error) {
	if row < 0 || row >= len(rec.Rows) {
		err = ErrRowError
		return
	}

	val = rec.Rows[row].Source_uid
	return
}

//查找发件人名称
func (rec *PlayerMailBox) FindSource_name(v string) int {
	for idx, row := range rec.Rows {
		if row.Source_name == v {
			return idx
		}
	}
	return -1
}

//查找发件人名称
func (rec *PlayerMailBox) FindNextSource_name(v string, itr int) int {
	itr++
	if itr+1 >= len(rec.Rows) {
		return -1
	}
	for idx, row := range rec.Rows[itr:] {
		if row.Source_name == v {
			return idx
		}
	}
	return -1
}

//设置发件人名称
func (rec *PlayerMailBox) SetSource_name(row int, v string) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the Source_name will be overwritten by scenedata")
	}

	if row < 0 || row >= len(rec.Rows) {
		return ErrRowError
	}

	rec.Rows[row].Source_name = v
	rec.Dirty = true
	if rec.syncer != nil {
		rec.syncer.RecModify(rec.owner, rec, row, 1)
	}
	return nil
}

//获取发件人名称
func (rec *PlayerMailBox) GetSource_name(row int) (val string, err error) {
	if row < 0 || row >= len(rec.Rows) {
		err = ErrRowError
		return
	}

	val = rec.Rows[row].Source_name
	return
}

//查找发件时间
func (rec *PlayerMailBox) FindSendTime(v int64) int {
	for idx, row := range rec.Rows {
		if row.SendTime == v {
			return idx
		}
	}
	return -1
}

//查找发件时间
func (rec *PlayerMailBox) FindNextSendTime(v int64, itr int) int {
	itr++
	if itr+1 >= len(rec.Rows) {
		return -1
	}
	for idx, row := range rec.Rows[itr:] {
		if row.SendTime == v {
			return idx
		}
	}
	return -1
}

//设置发件时间
func (rec *PlayerMailBox) SetSendTime(row int, v int64) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the SendTime will be overwritten by scenedata")
	}

	if row < 0 || row >= len(rec.Rows) {
		return ErrRowError
	}

	rec.Rows[row].SendTime = v
	rec.Dirty = true
	if rec.syncer != nil {
		rec.syncer.RecModify(rec.owner, rec, row, 2)
	}
	return nil
}

//获取发件时间
func (rec *PlayerMailBox) GetSendTime(row int) (val int64, err error) {
	if row < 0 || row >= len(rec.Rows) {
		err = ErrRowError
		return
	}

	val = rec.Rows[row].SendTime
	return
}

//查找标题
func (rec *PlayerMailBox) FindTitle(v string) int {
	for idx, row := range rec.Rows {
		if row.Title == v {
			return idx
		}
	}
	return -1
}

//查找标题
func (rec *PlayerMailBox) FindNextTitle(v string, itr int) int {
	itr++
	if itr+1 >= len(rec.Rows) {
		return -1
	}
	for idx, row := range rec.Rows[itr:] {
		if row.Title == v {
			return idx
		}
	}
	return -1
}

//设置标题
func (rec *PlayerMailBox) SetTitle(row int, v string) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the Title will be overwritten by scenedata")
	}

	if row < 0 || row >= len(rec.Rows) {
		return ErrRowError
	}

	rec.Rows[row].Title = v
	rec.Dirty = true
	if rec.syncer != nil {
		rec.syncer.RecModify(rec.owner, rec, row, 3)
	}
	return nil
}

//获取标题
func (rec *PlayerMailBox) GetTitle(row int) (val string, err error) {
	if row < 0 || row >= len(rec.Rows) {
		err = ErrRowError
		return
	}

	val = rec.Rows[row].Title
	return
}

//查找内容
func (rec *PlayerMailBox) FindContent(v string) int {
	for idx, row := range rec.Rows {
		if row.Content == v {
			return idx
		}
	}
	return -1
}

//查找内容
func (rec *PlayerMailBox) FindNextContent(v string, itr int) int {
	itr++
	if itr+1 >= len(rec.Rows) {
		return -1
	}
	for idx, row := range rec.Rows[itr:] {
		if row.Content == v {
			return idx
		}
	}
	return -1
}

//设置内容
func (rec *PlayerMailBox) SetContent(row int, v string) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the Content will be overwritten by scenedata")
	}

	if row < 0 || row >= len(rec.Rows) {
		return ErrRowError
	}

	rec.Rows[row].Content = v
	rec.Dirty = true
	if rec.syncer != nil {
		rec.syncer.RecModify(rec.owner, rec, row, 4)
	}
	return nil
}

//获取内容
func (rec *PlayerMailBox) GetContent(row int) (val string, err error) {
	if row < 0 || row >= len(rec.Rows) {
		err = ErrRowError
		return
	}

	val = rec.Rows[row].Content
	return
}

//查找附件
func (rec *PlayerMailBox) FindAppendix(v string) int {
	for idx, row := range rec.Rows {
		if row.Appendix == v {
			return idx
		}
	}
	return -1
}

//查找附件
func (rec *PlayerMailBox) FindNextAppendix(v string, itr int) int {
	itr++
	if itr+1 >= len(rec.Rows) {
		return -1
	}
	for idx, row := range rec.Rows[itr:] {
		if row.Appendix == v {
			return idx
		}
	}
	return -1
}

//设置附件
func (rec *PlayerMailBox) SetAppendix(row int, v string) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the Appendix will be overwritten by scenedata")
	}

	if row < 0 || row >= len(rec.Rows) {
		return ErrRowError
	}

	rec.Rows[row].Appendix = v
	rec.Dirty = true
	if rec.syncer != nil {
		rec.syncer.RecModify(rec.owner, rec, row, 5)
	}
	return nil
}

//获取附件
func (rec *PlayerMailBox) GetAppendix(row int) (val string, err error) {
	if row < 0 || row >= len(rec.Rows) {
		err = ErrRowError
		return
	}

	val = rec.Rows[row].Appendix
	return
}

//查找是否已读
func (rec *PlayerMailBox) FindIsRead(v int8) int {
	for idx, row := range rec.Rows {
		if row.IsRead == v {
			return idx
		}
	}
	return -1
}

//查找是否已读
func (rec *PlayerMailBox) FindNextIsRead(v int8, itr int) int {
	itr++
	if itr+1 >= len(rec.Rows) {
		return -1
	}
	for idx, row := range rec.Rows[itr:] {
		if row.IsRead == v {
			return idx
		}
	}
	return -1
}

//设置是否已读
func (rec *PlayerMailBox) SetIsRead(row int, v int8) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the IsRead will be overwritten by scenedata")
	}

	if row < 0 || row >= len(rec.Rows) {
		return ErrRowError
	}

	rec.Rows[row].IsRead = v
	rec.Dirty = true
	if rec.syncer != nil {
		rec.syncer.RecModify(rec.owner, rec, row, 6)
	}
	return nil
}

//获取是否已读
func (rec *PlayerMailBox) GetIsRead(row int) (val int8, err error) {
	if row < 0 || row >= len(rec.Rows) {
		err = ErrRowError
		return
	}

	val = rec.Rows[row].IsRead
	return
}

//查找邮件序列号
func (rec *PlayerMailBox) FindSerial_no(v uint64) int {
	for idx, row := range rec.Rows {
		if row.Serial_no == v {
			return idx
		}
	}
	return -1
}

//查找邮件序列号
func (rec *PlayerMailBox) FindNextSerial_no(v uint64, itr int) int {
	itr++
	if itr+1 >= len(rec.Rows) {
		return -1
	}
	for idx, row := range rec.Rows[itr:] {
		if row.Serial_no == v {
			return idx
		}
	}
	return -1
}

//设置邮件序列号
func (rec *PlayerMailBox) SetSerial_no(row int, v uint64) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the Serial_no will be overwritten by scenedata")
	}

	if row < 0 || row >= len(rec.Rows) {
		return ErrRowError
	}

	rec.Rows[row].Serial_no = v
	rec.Dirty = true
	if rec.syncer != nil {
		rec.syncer.RecModify(rec.owner, rec, row, 7)
	}
	return nil
}

//获取邮件序列号
func (rec *PlayerMailBox) GetSerial_no(row int) (val uint64, err error) {
	if row < 0 || row >= len(rec.Rows) {
		err = ErrRowError
		return
	}

	val = rec.Rows[row].Serial_no
	return
}

//查找邮件类型
func (rec *PlayerMailBox) FindMsgType(v int32) int {
	for idx, row := range rec.Rows {
		if row.MsgType == v {
			return idx
		}
	}
	return -1
}

//查找邮件类型
func (rec *PlayerMailBox) FindNextMsgType(v int32, itr int) int {
	itr++
	if itr+1 >= len(rec.Rows) {
		return -1
	}
	for idx, row := range rec.Rows[itr:] {
		if row.MsgType == v {
			return idx
		}
	}
	return -1
}

//设置邮件类型
func (rec *PlayerMailBox) SetMsgType(row int, v int32) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the MsgType will be overwritten by scenedata")
	}

	if row < 0 || row >= len(rec.Rows) {
		return ErrRowError
	}

	rec.Rows[row].MsgType = v
	rec.Dirty = true
	if rec.syncer != nil {
		rec.syncer.RecModify(rec.owner, rec, row, 8)
	}
	return nil
}

//获取邮件类型
func (rec *PlayerMailBox) GetMsgType(row int) (val int32, err error) {
	if row < 0 || row >= len(rec.Rows) {
		err = ErrRowError
		return
	}

	val = rec.Rows[row].MsgType
	return
}

//设置一行的值
func (rec *PlayerMailBox) SetRow(row int, args ...interface{}) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the MailBox will be overwritten by scenedata")
	}

	if _, ok := args[0].(uint64); !ok {
		return ErrColTypeError
	}
	if _, ok := args[1].(string); !ok {
		return ErrColTypeError
	}
	if _, ok := args[2].(int64); !ok {
		return ErrColTypeError
	}
	if _, ok := args[3].(string); !ok {
		return ErrColTypeError
	}
	if _, ok := args[4].(string); !ok {
		return ErrColTypeError
	}
	if _, ok := args[5].(string); !ok {
		return ErrColTypeError
	}
	if _, ok := args[6].(int8); !ok {
		return ErrColTypeError
	}
	if _, ok := args[7].(uint64); !ok {
		return ErrColTypeError
	}
	if _, ok := args[8].(int32); !ok {
		return ErrColTypeError
	}
	return rec.SetRowValue(row, args[0].(uint64), args[1].(string), args[2].(int64), args[3].(string), args[4].(string), args[5].(string), args[6].(int8), args[7].(uint64), args[8].(int32))
}

func (rec *PlayerMailBox) SetRowInterface(row int, rowvalue interface{}) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the MailBox will be overwritten by scenedata")
	}

	if row < 0 || row >= len(rec.Rows) {
		return ErrRowError
	}

	if value, ok := rowvalue.(PlayerMailBoxRow); ok {
		rec.Rows[row] = value
		if rec.syncer != nil {
			rec.syncer.RecSetRow(rec.owner, rec, row)
		}
		rec.Dirty = true
		return nil
	}

	return ErrColTypeError
}

func (rec *PlayerMailBox) SetRowByBytes(row int, rowdata []byte) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskAccepted will be overwritten by scenedata")
	}

	lr := util.NewLoadArchiver(rowdata)

	var source_uid uint64
	var source_name string
	var sendtime int64
	var title string
	var content string
	var appendix string
	var isread int8
	var serial_no uint64
	var msgtype int32

	if err := lr.Read(&source_uid); err != nil {
		return err
	}
	if err := lr.Read(&source_name); err != nil {
		return err
	}
	if err := lr.Read(&sendtime); err != nil {
		return err
	}
	if err := lr.Read(&title); err != nil {
		return err
	}
	if err := lr.Read(&content); err != nil {
		return err
	}
	if err := lr.Read(&appendix); err != nil {
		return err
	}
	if err := lr.Read(&isread); err != nil {
		return err
	}
	if err := lr.Read(&serial_no); err != nil {
		return err
	}
	if err := lr.Read(&msgtype); err != nil {
		return err
	}

	return rec.SetRowValue(row, source_uid, source_name, sendtime, title, content, appendix, isread, serial_no, msgtype)
}

//设置一行的值
func (rec *PlayerMailBox) SetRowValue(row int, source_uid uint64, source_name string, sendtime int64, title string, content string, appendix string, isread int8, serial_no uint64, msgtype int32) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the MailBox will be overwritten by scenedata")
	}

	if row < 0 || row >= len(rec.Rows) {
		return ErrRowError
	}

	rec.Rows[row].Source_uid = source_uid
	rec.Rows[row].Source_name = source_name
	rec.Rows[row].SendTime = sendtime
	rec.Rows[row].Title = title
	rec.Rows[row].Content = content
	rec.Rows[row].Appendix = appendix
	rec.Rows[row].IsRead = isread
	rec.Rows[row].Serial_no = serial_no
	rec.Rows[row].MsgType = msgtype

	if rec.syncer != nil {
		rec.syncer.RecSetRow(rec.owner, rec, row)
	}
	rec.Dirty = true
	return nil
}

//增加一行,row=-1时,在表格最后面插入一行,否则在row处插入,返回-1插入失败,否则返回插入的行号
func (rec *PlayerMailBox) Add(row int, args ...interface{}) int {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the MailBox will be overwritten by scenedata")
	}

	if len(args) != rec.Cols {
		return -1
	}

	if _, ok := args[0].(uint64); !ok {
		return -1
	}
	if _, ok := args[1].(string); !ok {
		return -1
	}
	if _, ok := args[2].(int64); !ok {
		return -1
	}
	if _, ok := args[3].(string); !ok {
		return -1
	}
	if _, ok := args[4].(string); !ok {
		return -1
	}
	if _, ok := args[5].(string); !ok {
		return -1
	}
	if _, ok := args[6].(int8); !ok {
		return -1
	}
	if _, ok := args[7].(uint64); !ok {
		return -1
	}
	if _, ok := args[8].(int32); !ok {
		return -1
	}
	return rec.AddRowValue(row, args[0].(uint64), args[1].(string), args[2].(int64), args[3].(string), args[4].(string), args[5].(string), args[6].(int8), args[7].(uint64), args[8].(int32))
}

//增加一行,row=-1时,在表格最后面插入一行,否则在row处插入,返回-1插入失败,否则返回插入的行号
func (rec *PlayerMailBox) AddByBytes(row int, rowdata []byte) int {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskAccepted will be overwritten by scenedata")
	}

	lr := util.NewLoadArchiver(rowdata)

	var source_uid uint64
	var source_name string
	var sendtime int64
	var title string
	var content string
	var appendix string
	var isread int8
	var serial_no uint64
	var msgtype int32

	if err := lr.Read(&source_uid); err != nil {
		return -1
	}
	if err := lr.Read(&source_name); err != nil {
		return -1
	}
	if err := lr.Read(&sendtime); err != nil {
		return -1
	}
	if err := lr.Read(&title); err != nil {
		return -1
	}
	if err := lr.Read(&content); err != nil {
		return -1
	}
	if err := lr.Read(&appendix); err != nil {
		return -1
	}
	if err := lr.Read(&isread); err != nil {
		return -1
	}
	if err := lr.Read(&serial_no); err != nil {
		return -1
	}
	if err := lr.Read(&msgtype); err != nil {
		return -1
	}

	return rec.AddRowValue(row, source_uid, source_name, sendtime, title, content, appendix, isread, serial_no, msgtype)
}

//增加一行,row=-1时,在表格最后面插入一行,否则在row处插入,返回-1插入失败,否则返回插入的行号
func (rec *PlayerMailBox) AddRow(row int) int {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the MailBox will be overwritten by scenedata")
	}
	add := -1

	if len(rec.Rows) >= rec.MaxRows {
		return add
	}

	r := PlayerMailBoxRow{}

	return rec.AddRowValue(row, r.Source_uid, r.Source_name, r.SendTime, r.Title, r.Content, r.Appendix, r.IsRead, r.Serial_no, r.MsgType)

}

//增加一行,row=-1时,在表格最后面插入一行,否则在row处插入,返回-1插入失败,否则返回插入的行号
func (rec *PlayerMailBox) AddRowValue(row int, source_uid uint64, source_name string, sendtime int64, title string, content string, appendix string, isread int8, serial_no uint64, msgtype int32) int {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the MailBox will be overwritten by scenedata")
	}

	add := -1

	if len(rec.Rows) >= rec.MaxRows {
		return add
	}

	r := PlayerMailBoxRow{source_uid, source_name, sendtime, title, content, appendix, isread, serial_no, msgtype}

	if row == -1 {
		rec.Rows = append(rec.Rows, r)
		add = len(rec.Rows) - 1
	} else {
		if row >= 0 && row < len(rec.Rows) {
			rec.Rows = append(rec.Rows, PlayerMailBoxRow{})
			copy(rec.Rows[row+1:], rec.Rows[row:])
			rec.Rows[row] = r
			add = row
		} else {
			rec.Rows = append(rec.Rows, r)
			add = len(rec.Rows) - 1
		}

	}
	if add != -1 {
		if rec.syncer != nil {
			rec.syncer.RecAppend(rec.owner, rec, add)
		}
		rec.Dirty = true
	}
	return add
}

//获取一行数据
func (rec *PlayerMailBox) GetRow(row int) (source_uid uint64, source_name string, sendtime int64, title string, content string, appendix string, isread int8, serial_no uint64, msgtype int32, err error) {

	if row < 0 || row >= len(rec.Rows) {
		err = ErrRowError
		return
	}

	r := rec.Rows[row]
	source_uid = r.Source_uid
	source_name = r.Source_name
	sendtime = r.SendTime
	title = r.Title
	content = r.Content
	appendix = r.Appendix
	isread = r.IsRead
	serial_no = r.Serial_no
	msgtype = r.MsgType

	return
}

//获取一行数据
func (rec *PlayerMailBox) GetRowInterface(row int) (rowvalue interface{}, err error) {

	if row < 0 || row >= len(rec.Rows) {
		err = ErrRowError
		return
	}

	rowvalue = rec.Rows[row]
	return
}

//获取数据
func (rec *PlayerMailBox) Scan(row int, source_uid *uint64, source_name *string, sendtime *int64, title *string, content *string, appendix *string, isread *int8, serial_no *uint64, msgtype *int32) bool {

	if row < 0 || row >= len(rec.Rows) {
		return false
	}

	r := rec.Rows[row]
	*source_uid = r.Source_uid
	*source_name = r.Source_name
	*sendtime = r.SendTime
	*title = r.Title
	*content = r.Content
	*appendix = r.Appendix
	*isread = r.IsRead
	*serial_no = r.Serial_no
	*msgtype = r.MsgType

	return true
}

//删除一行
func (rec *PlayerMailBox) Del(row int) {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the MailBox will be overwritten by scenedata")
	}
	if row < 0 || row >= len(rec.Rows) {
		return
	}

	copy(rec.Rows[row:], rec.Rows[row+1:])
	rec.Rows = rec.Rows[:len(rec.Rows)-1]
	rec.Dirty = true

	if rec.syncer != nil {
		rec.syncer.RecDelete(rec.owner, rec, row)
	}
}

//清空表格
func (rec *PlayerMailBox) Clear() {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the MailBox will be overwritten by scenedata")
	}
	rec.Rows = rec.Rows[:0]
	rec.Dirty = true
	if rec.syncer != nil {
		rec.syncer.RecClear(rec.owner, rec)
	}
}

//是否保存
func (rec *PlayerMailBox) IsSave() bool {
	return true
}

//初始化PlayerMailBox表
func (obj *Player) initPlayerMailBox() {
	obj.MailBox_r.MaxRows = 100
	obj.MailBox_r.Cols = 9
	obj.MailBox_r.Rows = make([]PlayerMailBoxRow, 0, 100)
	obj.MailBox_r.owner = obj
}

//获取PlayerMailBox表
func (obj *Player) GetPlayerMailBox() *PlayerMailBox {
	return &obj.MailBox_r
}

func (rec *PlayerTaskAccepted) Marshal() ([]byte, error) {
	return json.Marshal(rec)
}

func (rec *PlayerTaskAccepted) Unmarshal(data []byte) error {
	return json.Unmarshal(data, rec)
}

//DB
func (rec *PlayerTaskAccepted) Update(eq ExecQueryer, dbId uint64) error {

	if !rec.Dirty {
		return nil
	}

	data, err := rec.Marshal()
	if err != nil {
		return err
	}
	sql := "UPDATE `tbl_player` SET `r_taskaccepted`=? WHERE `id` = ?"

	if _, err := eq.Exec(sql, data, dbId); err != nil {
		log.LogError("update record PlayerTaskAccepted error:", sql, data, dbId)
		return err
	}

	return nil
}

func (rec *PlayerTaskAccepted) Load(eq ExecQueryer, dbId uint64) error {

	rec.Rows = rec.Rows[:0]

	sql := "SELECT `r_taskaccepted` FROM `tbl_player` WHERE `id`=? LIMIT 1"
	r, err := eq.Query(sql, dbId)
	if err != nil {
		log.LogError("load record PlayerTaskAccepted error:", err)
		return err
	}
	defer r.Close()
	if !r.Next() {
		log.LogError("load record PlayerTaskAccepted error:", sql, dbId)
		return ErrSqlRowError
	}
	var json []byte
	if err = r.Scan(&json); err != nil {
		log.LogError("load record PlayerTaskAccepted error:", err)
		return err
	}

	if json == nil || len(json) < 2 {
		log.LogWarning("load record PlayerTaskAccepted error: nil")
		return nil
	}

	err = rec.Unmarshal(json)
	if err != nil {
		log.LogError("unmarshal record PlayerTaskAccepted error:", err)
		return err
	}

	return nil
}

func (rec *PlayerTaskAccepted) GetName() string {
	return "TaskAccepted"
}

//表格的容量
func (rec *PlayerTaskAccepted) GetCap() int {
	return rec.MaxRows
}

//表格当前的行数
func (rec *PlayerTaskAccepted) GetRows() int {
	return len(rec.Rows)
}

//获取列定义
func (rec *PlayerTaskAccepted) ColTypes() ([]int, []string) {
	col := []int{DT_STRING, DT_INT8}
	cols := []string{"string", "int8"}
	return col, cols
}

//获取列数
func (rec *PlayerTaskAccepted) GetCols() int {
	return rec.Cols
}

//是否要同步到客户端
func (rec *PlayerTaskAccepted) IsVisible() bool {
	return true
}

//脏标志
func (rec *PlayerTaskAccepted) IsDirty() bool {
	return rec.Dirty
}

func (rec *PlayerTaskAccepted) ClearDirty() {
	rec.Dirty = false
}

func (rec *PlayerTaskAccepted) SetSyncer(s TableSyncer) {
	rec.syncer = s
}

func (rec *PlayerTaskAccepted) GetSyncer() TableSyncer {
	return rec.syncer
}

//序列化
func (rec *PlayerTaskAccepted) Serial() ([]byte, error) {
	ar := util.NewStoreArchiver(nil)
	for _, v := range rec.Rows {
		ar.WriteString(v.ID)
		ar.Write(v.Flag)
	}
	return ar.Data(), nil
}

//序列化一行
func (rec *PlayerTaskAccepted) SerialRow(row int) ([]byte, error) {
	if row < 0 || row >= len(rec.Rows) {
		return nil, ErrRowError
	}
	ar := util.NewStoreArchiver(nil)
	v := rec.Rows[row]
	ar.WriteString(v.ID)
	ar.Write(v.Flag)
	return ar.Data(), nil
}

//通过行列设置值
func (rec *PlayerTaskAccepted) Set(row, col int, val interface{}) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskAccepted will be overwritten by scenedata")
	}

	if row < 0 || row >= len(rec.Rows) {
		return ErrRowError
	}

	if col < 0 || col >= 2 {
		return ErrColError
	}

	r := &rec.Rows[row]

	switch col {
	case 0:
		val, ok := val.(string)
		if ok {
			r.ID = val
		} else {
			return ErrTypeMismatch
		}
	case 1:
		val, ok := val.(int8)
		if ok {
			r.Flag = val
		} else {
			return ErrTypeMismatch
		}
	}
	if rec.syncer != nil {
		rec.syncer.RecModify(rec.owner, rec, row, col)
	}
	rec.Dirty = true
	return nil
}

//通过行列获取值
func (rec *PlayerTaskAccepted) Get(row, col int) (val interface{}, err error) {
	if row < 0 || row >= len(rec.Rows) {
		err = ErrRowError
		return
	}

	if col < 0 || col >= 2 {
		err = ErrColError
		return
	}

	r := rec.Rows[row]

	switch col {
	case 0:
		val = r.ID
	case 1:
		val = r.Flag
	}

	return
}

//查找任务编号
func (rec *PlayerTaskAccepted) FindID(v string) int {
	for idx, row := range rec.Rows {
		if row.ID == v {
			return idx
		}
	}
	return -1
}

//查找任务编号
func (rec *PlayerTaskAccepted) FindNextID(v string, itr int) int {
	itr++
	if itr+1 >= len(rec.Rows) {
		return -1
	}
	for idx, row := range rec.Rows[itr:] {
		if row.ID == v {
			return idx
		}
	}
	return -1
}

//设置任务编号
func (rec *PlayerTaskAccepted) SetID(row int, v string) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the ID will be overwritten by scenedata")
	}

	if row < 0 || row >= len(rec.Rows) {
		return ErrRowError
	}

	rec.Rows[row].ID = v
	rec.Dirty = true
	if rec.syncer != nil {
		rec.syncer.RecModify(rec.owner, rec, row, 0)
	}
	return nil
}

//获取任务编号
func (rec *PlayerTaskAccepted) GetID(row int) (val string, err error) {
	if row < 0 || row >= len(rec.Rows) {
		err = ErrRowError
		return
	}

	val = rec.Rows[row].ID
	return
}

//查找任务标记
func (rec *PlayerTaskAccepted) FindFlag(v int8) int {
	for idx, row := range rec.Rows {
		if row.Flag == v {
			return idx
		}
	}
	return -1
}

//查找任务标记
func (rec *PlayerTaskAccepted) FindNextFlag(v int8, itr int) int {
	itr++
	if itr+1 >= len(rec.Rows) {
		return -1
	}
	for idx, row := range rec.Rows[itr:] {
		if row.Flag == v {
			return idx
		}
	}
	return -1
}

//设置任务标记
func (rec *PlayerTaskAccepted) SetFlag(row int, v int8) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the Flag will be overwritten by scenedata")
	}

	if row < 0 || row >= len(rec.Rows) {
		return ErrRowError
	}

	rec.Rows[row].Flag = v
	rec.Dirty = true
	if rec.syncer != nil {
		rec.syncer.RecModify(rec.owner, rec, row, 1)
	}
	return nil
}

//获取任务标记
func (rec *PlayerTaskAccepted) GetFlag(row int) (val int8, err error) {
	if row < 0 || row >= len(rec.Rows) {
		err = ErrRowError
		return
	}

	val = rec.Rows[row].Flag
	return
}

//设置一行的值
func (rec *PlayerTaskAccepted) SetRow(row int, args ...interface{}) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskAccepted will be overwritten by scenedata")
	}

	if _, ok := args[0].(string); !ok {
		return ErrColTypeError
	}
	if _, ok := args[1].(int8); !ok {
		return ErrColTypeError
	}
	return rec.SetRowValue(row, args[0].(string), args[1].(int8))
}

func (rec *PlayerTaskAccepted) SetRowInterface(row int, rowvalue interface{}) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskAccepted will be overwritten by scenedata")
	}

	if row < 0 || row >= len(rec.Rows) {
		return ErrRowError
	}

	if value, ok := rowvalue.(PlayerTaskAcceptedRow); ok {
		rec.Rows[row] = value
		if rec.syncer != nil {
			rec.syncer.RecSetRow(rec.owner, rec, row)
		}
		rec.Dirty = true
		return nil
	}

	return ErrColTypeError
}

func (rec *PlayerTaskAccepted) SetRowByBytes(row int, rowdata []byte) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskAccepted will be overwritten by scenedata")
	}

	lr := util.NewLoadArchiver(rowdata)

	var id string
	var flag int8

	if err := lr.Read(&id); err != nil {
		return err
	}
	if err := lr.Read(&flag); err != nil {
		return err
	}

	return rec.SetRowValue(row, id, flag)
}

//设置一行的值
func (rec *PlayerTaskAccepted) SetRowValue(row int, id string, flag int8) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskAccepted will be overwritten by scenedata")
	}

	if row < 0 || row >= len(rec.Rows) {
		return ErrRowError
	}

	rec.Rows[row].ID = id
	rec.Rows[row].Flag = flag

	if rec.syncer != nil {
		rec.syncer.RecSetRow(rec.owner, rec, row)
	}
	rec.Dirty = true
	return nil
}

//增加一行,row=-1时,在表格最后面插入一行,否则在row处插入,返回-1插入失败,否则返回插入的行号
func (rec *PlayerTaskAccepted) Add(row int, args ...interface{}) int {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskAccepted will be overwritten by scenedata")
	}

	if len(args) != rec.Cols {
		return -1
	}

	if _, ok := args[0].(string); !ok {
		return -1
	}
	if _, ok := args[1].(int8); !ok {
		return -1
	}
	return rec.AddRowValue(row, args[0].(string), args[1].(int8))
}

//增加一行,row=-1时,在表格最后面插入一行,否则在row处插入,返回-1插入失败,否则返回插入的行号
func (rec *PlayerTaskAccepted) AddByBytes(row int, rowdata []byte) int {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskAccepted will be overwritten by scenedata")
	}

	lr := util.NewLoadArchiver(rowdata)

	var id string
	var flag int8

	if err := lr.Read(&id); err != nil {
		return -1
	}
	if err := lr.Read(&flag); err != nil {
		return -1
	}

	return rec.AddRowValue(row, id, flag)
}

//增加一行,row=-1时,在表格最后面插入一行,否则在row处插入,返回-1插入失败,否则返回插入的行号
func (rec *PlayerTaskAccepted) AddRow(row int) int {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskAccepted will be overwritten by scenedata")
	}
	add := -1

	if len(rec.Rows) >= rec.MaxRows {
		return add
	}

	r := PlayerTaskAcceptedRow{}

	return rec.AddRowValue(row, r.ID, r.Flag)

}

//增加一行,row=-1时,在表格最后面插入一行,否则在row处插入,返回-1插入失败,否则返回插入的行号
func (rec *PlayerTaskAccepted) AddRowValue(row int, id string, flag int8) int {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskAccepted will be overwritten by scenedata")
	}

	add := -1

	if len(rec.Rows) >= rec.MaxRows {
		return add
	}

	r := PlayerTaskAcceptedRow{id, flag}

	if row == -1 {
		rec.Rows = append(rec.Rows, r)
		add = len(rec.Rows) - 1
	} else {
		if row >= 0 && row < len(rec.Rows) {
			rec.Rows = append(rec.Rows, PlayerTaskAcceptedRow{})
			copy(rec.Rows[row+1:], rec.Rows[row:])
			rec.Rows[row] = r
			add = row
		} else {
			rec.Rows = append(rec.Rows, r)
			add = len(rec.Rows) - 1
		}

	}
	if add != -1 {
		if rec.syncer != nil {
			rec.syncer.RecAppend(rec.owner, rec, add)
		}
		rec.Dirty = true
	}
	return add
}

//获取一行数据
func (rec *PlayerTaskAccepted) GetRow(row int) (id string, flag int8, err error) {

	if row < 0 || row >= len(rec.Rows) {
		err = ErrRowError
		return
	}

	r := rec.Rows[row]
	id = r.ID
	flag = r.Flag

	return
}

//获取一行数据
func (rec *PlayerTaskAccepted) GetRowInterface(row int) (rowvalue interface{}, err error) {

	if row < 0 || row >= len(rec.Rows) {
		err = ErrRowError
		return
	}

	rowvalue = rec.Rows[row]
	return
}

//获取数据
func (rec *PlayerTaskAccepted) Scan(row int, id *string, flag *int8) bool {

	if row < 0 || row >= len(rec.Rows) {
		return false
	}

	r := rec.Rows[row]
	*id = r.ID
	*flag = r.Flag

	return true
}

//删除一行
func (rec *PlayerTaskAccepted) Del(row int) {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskAccepted will be overwritten by scenedata")
	}
	if row < 0 || row >= len(rec.Rows) {
		return
	}

	copy(rec.Rows[row:], rec.Rows[row+1:])
	rec.Rows = rec.Rows[:len(rec.Rows)-1]
	rec.Dirty = true

	if rec.syncer != nil {
		rec.syncer.RecDelete(rec.owner, rec, row)
	}
}

//清空表格
func (rec *PlayerTaskAccepted) Clear() {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskAccepted will be overwritten by scenedata")
	}
	rec.Rows = rec.Rows[:0]
	rec.Dirty = true
	if rec.syncer != nil {
		rec.syncer.RecClear(rec.owner, rec)
	}
}

//是否保存
func (rec *PlayerTaskAccepted) IsSave() bool {
	return true
}

//初始化PlayerTaskAccepted表
func (obj *Player) initPlayerTaskAccepted() {
	obj.TaskAccepted_r.MaxRows = 1024
	obj.TaskAccepted_r.Cols = 2
	obj.TaskAccepted_r.Rows = make([]PlayerTaskAcceptedRow, 0, 1024)
	obj.TaskAccepted_r.owner = obj
}

//获取PlayerTaskAccepted表
func (obj *Player) GetPlayerTaskAccepted() *PlayerTaskAccepted {
	return &obj.TaskAccepted_r
}

func (rec *PlayerTaskRecord) Marshal() ([]byte, error) {
	return json.Marshal(rec)
}

func (rec *PlayerTaskRecord) Unmarshal(data []byte) error {
	return json.Unmarshal(data, rec)
}

//DB
func (rec *PlayerTaskRecord) Update(eq ExecQueryer, dbId uint64) error {

	if !rec.Dirty {
		return nil
	}

	data, err := rec.Marshal()
	if err != nil {
		return err
	}
	sql := "UPDATE `tbl_player` SET `r_taskrecord`=? WHERE `id` = ?"

	if _, err := eq.Exec(sql, data, dbId); err != nil {
		log.LogError("update record PlayerTaskRecord error:", sql, data, dbId)
		return err
	}

	return nil
}

func (rec *PlayerTaskRecord) Load(eq ExecQueryer, dbId uint64) error {

	rec.Rows = rec.Rows[:0]

	sql := "SELECT `r_taskrecord` FROM `tbl_player` WHERE `id`=? LIMIT 1"
	r, err := eq.Query(sql, dbId)
	if err != nil {
		log.LogError("load record PlayerTaskRecord error:", err)
		return err
	}
	defer r.Close()
	if !r.Next() {
		log.LogError("load record PlayerTaskRecord error:", sql, dbId)
		return ErrSqlRowError
	}
	var json []byte
	if err = r.Scan(&json); err != nil {
		log.LogError("load record PlayerTaskRecord error:", err)
		return err
	}

	if json == nil || len(json) < 2 {
		log.LogWarning("load record PlayerTaskRecord error: nil")
		return nil
	}

	err = rec.Unmarshal(json)
	if err != nil {
		log.LogError("unmarshal record PlayerTaskRecord error:", err)
		return err
	}

	return nil
}

func (rec *PlayerTaskRecord) GetName() string {
	return "TaskRecord"
}

//表格的容量
func (rec *PlayerTaskRecord) GetCap() int {
	return rec.MaxRows
}

//表格当前的行数
func (rec *PlayerTaskRecord) GetRows() int {
	return len(rec.Rows)
}

//获取列定义
func (rec *PlayerTaskRecord) ColTypes() ([]int, []string) {
	col := []int{DT_STRING, DT_INT32, DT_STRING, DT_INT32, DT_INT32, DT_INT8}
	cols := []string{"string", "int32", "string", "int32", "int32", "int8"}
	return col, cols
}

//获取列数
func (rec *PlayerTaskRecord) GetCols() int {
	return rec.Cols
}

//是否要同步到客户端
func (rec *PlayerTaskRecord) IsVisible() bool {
	return true
}

//脏标志
func (rec *PlayerTaskRecord) IsDirty() bool {
	return rec.Dirty
}

func (rec *PlayerTaskRecord) ClearDirty() {
	rec.Dirty = false
}

func (rec *PlayerTaskRecord) SetSyncer(s TableSyncer) {
	rec.syncer = s
}

func (rec *PlayerTaskRecord) GetSyncer() TableSyncer {
	return rec.syncer
}

//序列化
func (rec *PlayerTaskRecord) Serial() ([]byte, error) {
	ar := util.NewStoreArchiver(nil)
	for _, v := range rec.Rows {
		ar.WriteString(v.ID)
		ar.Write(v.Typ)
		ar.WriteString(v.Key)
		ar.Write(v.CurrentAmount)
		ar.Write(v.TotalAmount)
		ar.Write(v.Flag)
	}
	return ar.Data(), nil
}

//序列化一行
func (rec *PlayerTaskRecord) SerialRow(row int) ([]byte, error) {
	if row < 0 || row >= len(rec.Rows) {
		return nil, ErrRowError
	}
	ar := util.NewStoreArchiver(nil)
	v := rec.Rows[row]
	ar.WriteString(v.ID)
	ar.Write(v.Typ)
	ar.WriteString(v.Key)
	ar.Write(v.CurrentAmount)
	ar.Write(v.TotalAmount)
	ar.Write(v.Flag)
	return ar.Data(), nil
}

//通过行列设置值
func (rec *PlayerTaskRecord) Set(row, col int, val interface{}) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskRecord will be overwritten by scenedata")
	}

	if row < 0 || row >= len(rec.Rows) {
		return ErrRowError
	}

	if col < 0 || col >= 6 {
		return ErrColError
	}

	r := &rec.Rows[row]

	switch col {
	case 0:
		val, ok := val.(string)
		if ok {
			r.ID = val
		} else {
			return ErrTypeMismatch
		}
	case 1:
		val, ok := val.(int32)
		if ok {
			r.Typ = val
		} else {
			return ErrTypeMismatch
		}
	case 2:
		val, ok := val.(string)
		if ok {
			r.Key = val
		} else {
			return ErrTypeMismatch
		}
	case 3:
		val, ok := val.(int32)
		if ok {
			r.CurrentAmount = val
		} else {
			return ErrTypeMismatch
		}
	case 4:
		val, ok := val.(int32)
		if ok {
			r.TotalAmount = val
		} else {
			return ErrTypeMismatch
		}
	case 5:
		val, ok := val.(int8)
		if ok {
			r.Flag = val
		} else {
			return ErrTypeMismatch
		}
	}
	if rec.syncer != nil {
		rec.syncer.RecModify(rec.owner, rec, row, col)
	}
	rec.Dirty = true
	return nil
}

//通过行列获取值
func (rec *PlayerTaskRecord) Get(row, col int) (val interface{}, err error) {
	if row < 0 || row >= len(rec.Rows) {
		err = ErrRowError
		return
	}

	if col < 0 || col >= 6 {
		err = ErrColError
		return
	}

	r := rec.Rows[row]

	switch col {
	case 0:
		val = r.ID
	case 1:
		val = r.Typ
	case 2:
		val = r.Key
	case 3:
		val = r.CurrentAmount
	case 4:
		val = r.TotalAmount
	case 5:
		val = r.Flag
	}

	return
}

//查找任务编号
func (rec *PlayerTaskRecord) FindID(v string) int {
	for idx, row := range rec.Rows {
		if row.ID == v {
			return idx
		}
	}
	return -1
}

//查找任务编号
func (rec *PlayerTaskRecord) FindNextID(v string, itr int) int {
	itr++
	if itr+1 >= len(rec.Rows) {
		return -1
	}
	for idx, row := range rec.Rows[itr:] {
		if row.ID == v {
			return idx
		}
	}
	return -1
}

//设置任务编号
func (rec *PlayerTaskRecord) SetID(row int, v string) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the ID will be overwritten by scenedata")
	}

	if row < 0 || row >= len(rec.Rows) {
		return ErrRowError
	}

	rec.Rows[row].ID = v
	rec.Dirty = true
	if rec.syncer != nil {
		rec.syncer.RecModify(rec.owner, rec, row, 0)
	}
	return nil
}

//获取任务编号
func (rec *PlayerTaskRecord) GetID(row int) (val string, err error) {
	if row < 0 || row >= len(rec.Rows) {
		err = ErrRowError
		return
	}

	val = rec.Rows[row].ID
	return
}

//查找记录类型
func (rec *PlayerTaskRecord) FindTyp(v int32) int {
	for idx, row := range rec.Rows {
		if row.Typ == v {
			return idx
		}
	}
	return -1
}

//查找记录类型
func (rec *PlayerTaskRecord) FindNextTyp(v int32, itr int) int {
	itr++
	if itr+1 >= len(rec.Rows) {
		return -1
	}
	for idx, row := range rec.Rows[itr:] {
		if row.Typ == v {
			return idx
		}
	}
	return -1
}

//设置记录类型
func (rec *PlayerTaskRecord) SetTyp(row int, v int32) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the Typ will be overwritten by scenedata")
	}

	if row < 0 || row >= len(rec.Rows) {
		return ErrRowError
	}

	rec.Rows[row].Typ = v
	rec.Dirty = true
	if rec.syncer != nil {
		rec.syncer.RecModify(rec.owner, rec, row, 1)
	}
	return nil
}

//获取记录类型
func (rec *PlayerTaskRecord) GetTyp(row int) (val int32, err error) {
	if row < 0 || row >= len(rec.Rows) {
		err = ErrRowError
		return
	}

	val = rec.Rows[row].Typ
	return
}

//查找关键字ID(如物品编号、NPC编号等等)
func (rec *PlayerTaskRecord) FindKey(v string) int {
	for idx, row := range rec.Rows {
		if row.Key == v {
			return idx
		}
	}
	return -1
}

//查找关键字ID(如物品编号、NPC编号等等)
func (rec *PlayerTaskRecord) FindNextKey(v string, itr int) int {
	itr++
	if itr+1 >= len(rec.Rows) {
		return -1
	}
	for idx, row := range rec.Rows[itr:] {
		if row.Key == v {
			return idx
		}
	}
	return -1
}

//设置关键字ID(如物品编号、NPC编号等等)
func (rec *PlayerTaskRecord) SetKey(row int, v string) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the Key will be overwritten by scenedata")
	}

	if row < 0 || row >= len(rec.Rows) {
		return ErrRowError
	}

	rec.Rows[row].Key = v
	rec.Dirty = true
	if rec.syncer != nil {
		rec.syncer.RecModify(rec.owner, rec, row, 2)
	}
	return nil
}

//获取关键字ID(如物品编号、NPC编号等等)
func (rec *PlayerTaskRecord) GetKey(row int) (val string, err error) {
	if row < 0 || row >= len(rec.Rows) {
		err = ErrRowError
		return
	}

	val = rec.Rows[row].Key
	return
}

//查找当前完成度
func (rec *PlayerTaskRecord) FindCurrentAmount(v int32) int {
	for idx, row := range rec.Rows {
		if row.CurrentAmount == v {
			return idx
		}
	}
	return -1
}

//查找当前完成度
func (rec *PlayerTaskRecord) FindNextCurrentAmount(v int32, itr int) int {
	itr++
	if itr+1 >= len(rec.Rows) {
		return -1
	}
	for idx, row := range rec.Rows[itr:] {
		if row.CurrentAmount == v {
			return idx
		}
	}
	return -1
}

//设置当前完成度
func (rec *PlayerTaskRecord) SetCurrentAmount(row int, v int32) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the CurrentAmount will be overwritten by scenedata")
	}

	if row < 0 || row >= len(rec.Rows) {
		return ErrRowError
	}

	rec.Rows[row].CurrentAmount = v
	rec.Dirty = true
	if rec.syncer != nil {
		rec.syncer.RecModify(rec.owner, rec, row, 3)
	}
	return nil
}

//获取当前完成度
func (rec *PlayerTaskRecord) GetCurrentAmount(row int) (val int32, err error) {
	if row < 0 || row >= len(rec.Rows) {
		err = ErrRowError
		return
	}

	val = rec.Rows[row].CurrentAmount
	return
}

//查找总进度
func (rec *PlayerTaskRecord) FindTotalAmount(v int32) int {
	for idx, row := range rec.Rows {
		if row.TotalAmount == v {
			return idx
		}
	}
	return -1
}

//查找总进度
func (rec *PlayerTaskRecord) FindNextTotalAmount(v int32, itr int) int {
	itr++
	if itr+1 >= len(rec.Rows) {
		return -1
	}
	for idx, row := range rec.Rows[itr:] {
		if row.TotalAmount == v {
			return idx
		}
	}
	return -1
}

//设置总进度
func (rec *PlayerTaskRecord) SetTotalAmount(row int, v int32) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TotalAmount will be overwritten by scenedata")
	}

	if row < 0 || row >= len(rec.Rows) {
		return ErrRowError
	}

	rec.Rows[row].TotalAmount = v
	rec.Dirty = true
	if rec.syncer != nil {
		rec.syncer.RecModify(rec.owner, rec, row, 4)
	}
	return nil
}

//获取总进度
func (rec *PlayerTaskRecord) GetTotalAmount(row int) (val int32, err error) {
	if row < 0 || row >= len(rec.Rows) {
		err = ErrRowError
		return
	}

	val = rec.Rows[row].TotalAmount
	return
}

//查找任务标记
func (rec *PlayerTaskRecord) FindFlag(v int8) int {
	for idx, row := range rec.Rows {
		if row.Flag == v {
			return idx
		}
	}
	return -1
}

//查找任务标记
func (rec *PlayerTaskRecord) FindNextFlag(v int8, itr int) int {
	itr++
	if itr+1 >= len(rec.Rows) {
		return -1
	}
	for idx, row := range rec.Rows[itr:] {
		if row.Flag == v {
			return idx
		}
	}
	return -1
}

//设置任务标记
func (rec *PlayerTaskRecord) SetFlag(row int, v int8) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the Flag will be overwritten by scenedata")
	}

	if row < 0 || row >= len(rec.Rows) {
		return ErrRowError
	}

	rec.Rows[row].Flag = v
	rec.Dirty = true
	if rec.syncer != nil {
		rec.syncer.RecModify(rec.owner, rec, row, 5)
	}
	return nil
}

//获取任务标记
func (rec *PlayerTaskRecord) GetFlag(row int) (val int8, err error) {
	if row < 0 || row >= len(rec.Rows) {
		err = ErrRowError
		return
	}

	val = rec.Rows[row].Flag
	return
}

//设置一行的值
func (rec *PlayerTaskRecord) SetRow(row int, args ...interface{}) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskRecord will be overwritten by scenedata")
	}

	if _, ok := args[0].(string); !ok {
		return ErrColTypeError
	}
	if _, ok := args[1].(int32); !ok {
		return ErrColTypeError
	}
	if _, ok := args[2].(string); !ok {
		return ErrColTypeError
	}
	if _, ok := args[3].(int32); !ok {
		return ErrColTypeError
	}
	if _, ok := args[4].(int32); !ok {
		return ErrColTypeError
	}
	if _, ok := args[5].(int8); !ok {
		return ErrColTypeError
	}
	return rec.SetRowValue(row, args[0].(string), args[1].(int32), args[2].(string), args[3].(int32), args[4].(int32), args[5].(int8))
}

func (rec *PlayerTaskRecord) SetRowInterface(row int, rowvalue interface{}) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskRecord will be overwritten by scenedata")
	}

	if row < 0 || row >= len(rec.Rows) {
		return ErrRowError
	}

	if value, ok := rowvalue.(PlayerTaskRecordRow); ok {
		rec.Rows[row] = value
		if rec.syncer != nil {
			rec.syncer.RecSetRow(rec.owner, rec, row)
		}
		rec.Dirty = true
		return nil
	}

	return ErrColTypeError
}

func (rec *PlayerTaskRecord) SetRowByBytes(row int, rowdata []byte) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskAccepted will be overwritten by scenedata")
	}

	lr := util.NewLoadArchiver(rowdata)

	var id string
	var typ int32
	var key string
	var currentamount int32
	var totalamount int32
	var flag int8

	if err := lr.Read(&id); err != nil {
		return err
	}
	if err := lr.Read(&typ); err != nil {
		return err
	}
	if err := lr.Read(&key); err != nil {
		return err
	}
	if err := lr.Read(&currentamount); err != nil {
		return err
	}
	if err := lr.Read(&totalamount); err != nil {
		return err
	}
	if err := lr.Read(&flag); err != nil {
		return err
	}

	return rec.SetRowValue(row, id, typ, key, currentamount, totalamount, flag)
}

//设置一行的值
func (rec *PlayerTaskRecord) SetRowValue(row int, id string, typ int32, key string, currentamount int32, totalamount int32, flag int8) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskRecord will be overwritten by scenedata")
	}

	if row < 0 || row >= len(rec.Rows) {
		return ErrRowError
	}

	rec.Rows[row].ID = id
	rec.Rows[row].Typ = typ
	rec.Rows[row].Key = key
	rec.Rows[row].CurrentAmount = currentamount
	rec.Rows[row].TotalAmount = totalamount
	rec.Rows[row].Flag = flag

	if rec.syncer != nil {
		rec.syncer.RecSetRow(rec.owner, rec, row)
	}
	rec.Dirty = true
	return nil
}

//增加一行,row=-1时,在表格最后面插入一行,否则在row处插入,返回-1插入失败,否则返回插入的行号
func (rec *PlayerTaskRecord) Add(row int, args ...interface{}) int {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskRecord will be overwritten by scenedata")
	}

	if len(args) != rec.Cols {
		return -1
	}

	if _, ok := args[0].(string); !ok {
		return -1
	}
	if _, ok := args[1].(int32); !ok {
		return -1
	}
	if _, ok := args[2].(string); !ok {
		return -1
	}
	if _, ok := args[3].(int32); !ok {
		return -1
	}
	if _, ok := args[4].(int32); !ok {
		return -1
	}
	if _, ok := args[5].(int8); !ok {
		return -1
	}
	return rec.AddRowValue(row, args[0].(string), args[1].(int32), args[2].(string), args[3].(int32), args[4].(int32), args[5].(int8))
}

//增加一行,row=-1时,在表格最后面插入一行,否则在row处插入,返回-1插入失败,否则返回插入的行号
func (rec *PlayerTaskRecord) AddByBytes(row int, rowdata []byte) int {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskAccepted will be overwritten by scenedata")
	}

	lr := util.NewLoadArchiver(rowdata)

	var id string
	var typ int32
	var key string
	var currentamount int32
	var totalamount int32
	var flag int8

	if err := lr.Read(&id); err != nil {
		return -1
	}
	if err := lr.Read(&typ); err != nil {
		return -1
	}
	if err := lr.Read(&key); err != nil {
		return -1
	}
	if err := lr.Read(&currentamount); err != nil {
		return -1
	}
	if err := lr.Read(&totalamount); err != nil {
		return -1
	}
	if err := lr.Read(&flag); err != nil {
		return -1
	}

	return rec.AddRowValue(row, id, typ, key, currentamount, totalamount, flag)
}

//增加一行,row=-1时,在表格最后面插入一行,否则在row处插入,返回-1插入失败,否则返回插入的行号
func (rec *PlayerTaskRecord) AddRow(row int) int {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskRecord will be overwritten by scenedata")
	}
	add := -1

	if len(rec.Rows) >= rec.MaxRows {
		return add
	}

	r := PlayerTaskRecordRow{}

	return rec.AddRowValue(row, r.ID, r.Typ, r.Key, r.CurrentAmount, r.TotalAmount, r.Flag)

}

//增加一行,row=-1时,在表格最后面插入一行,否则在row处插入,返回-1插入失败,否则返回插入的行号
func (rec *PlayerTaskRecord) AddRowValue(row int, id string, typ int32, key string, currentamount int32, totalamount int32, flag int8) int {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskRecord will be overwritten by scenedata")
	}

	add := -1

	if len(rec.Rows) >= rec.MaxRows {
		return add
	}

	r := PlayerTaskRecordRow{id, typ, key, currentamount, totalamount, flag}

	if row == -1 {
		rec.Rows = append(rec.Rows, r)
		add = len(rec.Rows) - 1
	} else {
		if row >= 0 && row < len(rec.Rows) {
			rec.Rows = append(rec.Rows, PlayerTaskRecordRow{})
			copy(rec.Rows[row+1:], rec.Rows[row:])
			rec.Rows[row] = r
			add = row
		} else {
			rec.Rows = append(rec.Rows, r)
			add = len(rec.Rows) - 1
		}

	}
	if add != -1 {
		if rec.syncer != nil {
			rec.syncer.RecAppend(rec.owner, rec, add)
		}
		rec.Dirty = true
	}
	return add
}

//获取一行数据
func (rec *PlayerTaskRecord) GetRow(row int) (id string, typ int32, key string, currentamount int32, totalamount int32, flag int8, err error) {

	if row < 0 || row >= len(rec.Rows) {
		err = ErrRowError
		return
	}

	r := rec.Rows[row]
	id = r.ID
	typ = r.Typ
	key = r.Key
	currentamount = r.CurrentAmount
	totalamount = r.TotalAmount
	flag = r.Flag

	return
}

//获取一行数据
func (rec *PlayerTaskRecord) GetRowInterface(row int) (rowvalue interface{}, err error) {

	if row < 0 || row >= len(rec.Rows) {
		err = ErrRowError
		return
	}

	rowvalue = rec.Rows[row]
	return
}

//获取数据
func (rec *PlayerTaskRecord) Scan(row int, id *string, typ *int32, key *string, currentamount *int32, totalamount *int32, flag *int8) bool {

	if row < 0 || row >= len(rec.Rows) {
		return false
	}

	r := rec.Rows[row]
	*id = r.ID
	*typ = r.Typ
	*key = r.Key
	*currentamount = r.CurrentAmount
	*totalamount = r.TotalAmount
	*flag = r.Flag

	return true
}

//删除一行
func (rec *PlayerTaskRecord) Del(row int) {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskRecord will be overwritten by scenedata")
	}
	if row < 0 || row >= len(rec.Rows) {
		return
	}

	copy(rec.Rows[row:], rec.Rows[row+1:])
	rec.Rows = rec.Rows[:len(rec.Rows)-1]
	rec.Dirty = true

	if rec.syncer != nil {
		rec.syncer.RecDelete(rec.owner, rec, row)
	}
}

//清空表格
func (rec *PlayerTaskRecord) Clear() {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskRecord will be overwritten by scenedata")
	}
	rec.Rows = rec.Rows[:0]
	rec.Dirty = true
	if rec.syncer != nil {
		rec.syncer.RecClear(rec.owner, rec)
	}
}

//是否保存
func (rec *PlayerTaskRecord) IsSave() bool {
	return true
}

//初始化PlayerTaskRecord表
func (obj *Player) initPlayerTaskRecord() {
	obj.TaskRecord_r.MaxRows = 1024
	obj.TaskRecord_r.Cols = 6
	obj.TaskRecord_r.Rows = make([]PlayerTaskRecordRow, 0, 1024)
	obj.TaskRecord_r.owner = obj
}

//获取PlayerTaskRecord表
func (obj *Player) GetPlayerTaskRecord() *PlayerTaskRecord {
	return &obj.TaskRecord_r
}

func (rec *PlayerTaskCanAccept) Marshal() ([]byte, error) {
	return json.Marshal(rec)
}

func (rec *PlayerTaskCanAccept) Unmarshal(data []byte) error {
	return json.Unmarshal(data, rec)
}

//DB
func (rec *PlayerTaskCanAccept) Update(eq ExecQueryer, dbId uint64) error {

	if !rec.Dirty {
		return nil
	}

	data, err := rec.Marshal()
	if err != nil {
		return err
	}
	sql := "UPDATE `tbl_player` SET `r_taskcanaccept`=? WHERE `id` = ?"

	if _, err := eq.Exec(sql, data, dbId); err != nil {
		log.LogError("update record PlayerTaskCanAccept error:", sql, data, dbId)
		return err
	}

	return nil
}

func (rec *PlayerTaskCanAccept) Load(eq ExecQueryer, dbId uint64) error {

	rec.Rows = rec.Rows[:0]

	sql := "SELECT `r_taskcanaccept` FROM `tbl_player` WHERE `id`=? LIMIT 1"
	r, err := eq.Query(sql, dbId)
	if err != nil {
		log.LogError("load record PlayerTaskCanAccept error:", err)
		return err
	}
	defer r.Close()
	if !r.Next() {
		log.LogError("load record PlayerTaskCanAccept error:", sql, dbId)
		return ErrSqlRowError
	}
	var json []byte
	if err = r.Scan(&json); err != nil {
		log.LogError("load record PlayerTaskCanAccept error:", err)
		return err
	}

	if json == nil || len(json) < 2 {
		log.LogWarning("load record PlayerTaskCanAccept error: nil")
		return nil
	}

	err = rec.Unmarshal(json)
	if err != nil {
		log.LogError("unmarshal record PlayerTaskCanAccept error:", err)
		return err
	}

	return nil
}

func (rec *PlayerTaskCanAccept) GetName() string {
	return "TaskCanAccept"
}

//表格的容量
func (rec *PlayerTaskCanAccept) GetCap() int {
	return rec.MaxRows
}

//表格当前的行数
func (rec *PlayerTaskCanAccept) GetRows() int {
	return len(rec.Rows)
}

//获取列定义
func (rec *PlayerTaskCanAccept) ColTypes() ([]int, []string) {
	col := []int{DT_STRING}
	cols := []string{"string"}
	return col, cols
}

//获取列数
func (rec *PlayerTaskCanAccept) GetCols() int {
	return rec.Cols
}

//是否要同步到客户端
func (rec *PlayerTaskCanAccept) IsVisible() bool {
	return true
}

//脏标志
func (rec *PlayerTaskCanAccept) IsDirty() bool {
	return rec.Dirty
}

func (rec *PlayerTaskCanAccept) ClearDirty() {
	rec.Dirty = false
}

func (rec *PlayerTaskCanAccept) SetSyncer(s TableSyncer) {
	rec.syncer = s
}

func (rec *PlayerTaskCanAccept) GetSyncer() TableSyncer {
	return rec.syncer
}

//序列化
func (rec *PlayerTaskCanAccept) Serial() ([]byte, error) {
	ar := util.NewStoreArchiver(nil)
	for _, v := range rec.Rows {
		ar.WriteString(v.ID)
	}
	return ar.Data(), nil
}

//序列化一行
func (rec *PlayerTaskCanAccept) SerialRow(row int) ([]byte, error) {
	if row < 0 || row >= len(rec.Rows) {
		return nil, ErrRowError
	}
	ar := util.NewStoreArchiver(nil)
	v := rec.Rows[row]
	ar.WriteString(v.ID)
	return ar.Data(), nil
}

//通过行列设置值
func (rec *PlayerTaskCanAccept) Set(row, col int, val interface{}) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskCanAccept will be overwritten by scenedata")
	}

	if row < 0 || row >= len(rec.Rows) {
		return ErrRowError
	}

	if col < 0 || col >= 1 {
		return ErrColError
	}

	r := &rec.Rows[row]

	switch col {
	case 0:
		val, ok := val.(string)
		if ok {
			r.ID = val
		} else {
			return ErrTypeMismatch
		}
	}
	if rec.syncer != nil {
		rec.syncer.RecModify(rec.owner, rec, row, col)
	}
	rec.Dirty = true
	return nil
}

//通过行列获取值
func (rec *PlayerTaskCanAccept) Get(row, col int) (val interface{}, err error) {
	if row < 0 || row >= len(rec.Rows) {
		err = ErrRowError
		return
	}

	if col < 0 || col >= 1 {
		err = ErrColError
		return
	}

	r := rec.Rows[row]

	switch col {
	case 0:
		val = r.ID
	}

	return
}

//查找任务编号
func (rec *PlayerTaskCanAccept) FindID(v string) int {
	for idx, row := range rec.Rows {
		if row.ID == v {
			return idx
		}
	}
	return -1
}

//查找任务编号
func (rec *PlayerTaskCanAccept) FindNextID(v string, itr int) int {
	itr++
	if itr+1 >= len(rec.Rows) {
		return -1
	}
	for idx, row := range rec.Rows[itr:] {
		if row.ID == v {
			return idx
		}
	}
	return -1
}

//设置任务编号
func (rec *PlayerTaskCanAccept) SetID(row int, v string) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the ID will be overwritten by scenedata")
	}

	if row < 0 || row >= len(rec.Rows) {
		return ErrRowError
	}

	rec.Rows[row].ID = v
	rec.Dirty = true
	if rec.syncer != nil {
		rec.syncer.RecModify(rec.owner, rec, row, 0)
	}
	return nil
}

//获取任务编号
func (rec *PlayerTaskCanAccept) GetID(row int) (val string, err error) {
	if row < 0 || row >= len(rec.Rows) {
		err = ErrRowError
		return
	}

	val = rec.Rows[row].ID
	return
}

//设置一行的值
func (rec *PlayerTaskCanAccept) SetRow(row int, args ...interface{}) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskCanAccept will be overwritten by scenedata")
	}

	if _, ok := args[0].(string); !ok {
		return ErrColTypeError
	}
	return rec.SetRowValue(row, args[0].(string))
}

func (rec *PlayerTaskCanAccept) SetRowInterface(row int, rowvalue interface{}) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskCanAccept will be overwritten by scenedata")
	}

	if row < 0 || row >= len(rec.Rows) {
		return ErrRowError
	}

	if value, ok := rowvalue.(PlayerTaskCanAcceptRow); ok {
		rec.Rows[row] = value
		if rec.syncer != nil {
			rec.syncer.RecSetRow(rec.owner, rec, row)
		}
		rec.Dirty = true
		return nil
	}

	return ErrColTypeError
}

func (rec *PlayerTaskCanAccept) SetRowByBytes(row int, rowdata []byte) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskAccepted will be overwritten by scenedata")
	}

	lr := util.NewLoadArchiver(rowdata)

	var id string

	if err := lr.Read(&id); err != nil {
		return err
	}

	return rec.SetRowValue(row, id)
}

//设置一行的值
func (rec *PlayerTaskCanAccept) SetRowValue(row int, id string) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskCanAccept will be overwritten by scenedata")
	}

	if row < 0 || row >= len(rec.Rows) {
		return ErrRowError
	}

	rec.Rows[row].ID = id

	if rec.syncer != nil {
		rec.syncer.RecSetRow(rec.owner, rec, row)
	}
	rec.Dirty = true
	return nil
}

//增加一行,row=-1时,在表格最后面插入一行,否则在row处插入,返回-1插入失败,否则返回插入的行号
func (rec *PlayerTaskCanAccept) Add(row int, args ...interface{}) int {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskCanAccept will be overwritten by scenedata")
	}

	if len(args) != rec.Cols {
		return -1
	}

	if _, ok := args[0].(string); !ok {
		return -1
	}
	return rec.AddRowValue(row, args[0].(string))
}

//增加一行,row=-1时,在表格最后面插入一行,否则在row处插入,返回-1插入失败,否则返回插入的行号
func (rec *PlayerTaskCanAccept) AddByBytes(row int, rowdata []byte) int {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskAccepted will be overwritten by scenedata")
	}

	lr := util.NewLoadArchiver(rowdata)

	var id string

	if err := lr.Read(&id); err != nil {
		return -1
	}

	return rec.AddRowValue(row, id)
}

//增加一行,row=-1时,在表格最后面插入一行,否则在row处插入,返回-1插入失败,否则返回插入的行号
func (rec *PlayerTaskCanAccept) AddRow(row int) int {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskCanAccept will be overwritten by scenedata")
	}
	add := -1

	if len(rec.Rows) >= rec.MaxRows {
		return add
	}

	r := PlayerTaskCanAcceptRow{}

	return rec.AddRowValue(row, r.ID)

}

//增加一行,row=-1时,在表格最后面插入一行,否则在row处插入,返回-1插入失败,否则返回插入的行号
func (rec *PlayerTaskCanAccept) AddRowValue(row int, id string) int {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskCanAccept will be overwritten by scenedata")
	}

	add := -1

	if len(rec.Rows) >= rec.MaxRows {
		return add
	}

	r := PlayerTaskCanAcceptRow{id}

	if row == -1 {
		rec.Rows = append(rec.Rows, r)
		add = len(rec.Rows) - 1
	} else {
		if row >= 0 && row < len(rec.Rows) {
			rec.Rows = append(rec.Rows, PlayerTaskCanAcceptRow{})
			copy(rec.Rows[row+1:], rec.Rows[row:])
			rec.Rows[row] = r
			add = row
		} else {
			rec.Rows = append(rec.Rows, r)
			add = len(rec.Rows) - 1
		}

	}
	if add != -1 {
		if rec.syncer != nil {
			rec.syncer.RecAppend(rec.owner, rec, add)
		}
		rec.Dirty = true
	}
	return add
}

//获取一行数据
func (rec *PlayerTaskCanAccept) GetRow(row int) (id string, err error) {

	if row < 0 || row >= len(rec.Rows) {
		err = ErrRowError
		return
	}

	r := rec.Rows[row]
	id = r.ID

	return
}

//获取一行数据
func (rec *PlayerTaskCanAccept) GetRowInterface(row int) (rowvalue interface{}, err error) {

	if row < 0 || row >= len(rec.Rows) {
		err = ErrRowError
		return
	}

	rowvalue = rec.Rows[row]
	return
}

//获取数据
func (rec *PlayerTaskCanAccept) Scan(row int, id *string) bool {

	if row < 0 || row >= len(rec.Rows) {
		return false
	}

	r := rec.Rows[row]
	*id = r.ID

	return true
}

//删除一行
func (rec *PlayerTaskCanAccept) Del(row int) {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskCanAccept will be overwritten by scenedata")
	}
	if row < 0 || row >= len(rec.Rows) {
		return
	}

	copy(rec.Rows[row:], rec.Rows[row+1:])
	rec.Rows = rec.Rows[:len(rec.Rows)-1]
	rec.Dirty = true

	if rec.syncer != nil {
		rec.syncer.RecDelete(rec.owner, rec, row)
	}
}

//清空表格
func (rec *PlayerTaskCanAccept) Clear() {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskCanAccept will be overwritten by scenedata")
	}
	rec.Rows = rec.Rows[:0]
	rec.Dirty = true
	if rec.syncer != nil {
		rec.syncer.RecClear(rec.owner, rec)
	}
}

//是否保存
func (rec *PlayerTaskCanAccept) IsSave() bool {
	return true
}

//初始化PlayerTaskCanAccept表
func (obj *Player) initPlayerTaskCanAccept() {
	obj.TaskCanAccept_r.MaxRows = 1024
	obj.TaskCanAccept_r.Cols = 1
	obj.TaskCanAccept_r.Rows = make([]PlayerTaskCanAcceptRow, 0, 1024)
	obj.TaskCanAccept_r.owner = obj
}

//获取PlayerTaskCanAccept表
func (obj *Player) GetPlayerTaskCanAccept() *PlayerTaskCanAccept {
	return &obj.TaskCanAccept_r
}

func (rec *PlayerTaskTimeLimit) Marshal() ([]byte, error) {
	return json.Marshal(rec)
}

func (rec *PlayerTaskTimeLimit) Unmarshal(data []byte) error {
	return json.Unmarshal(data, rec)
}

//DB
func (rec *PlayerTaskTimeLimit) Update(eq ExecQueryer, dbId uint64) error {

	if !rec.Dirty {
		return nil
	}

	data, err := rec.Marshal()
	if err != nil {
		return err
	}
	sql := "UPDATE `tbl_player` SET `r_tasktimelimit`=? WHERE `id` = ?"

	if _, err := eq.Exec(sql, data, dbId); err != nil {
		log.LogError("update record PlayerTaskTimeLimit error:", sql, data, dbId)
		return err
	}

	return nil
}

func (rec *PlayerTaskTimeLimit) Load(eq ExecQueryer, dbId uint64) error {

	rec.Rows = rec.Rows[:0]

	sql := "SELECT `r_tasktimelimit` FROM `tbl_player` WHERE `id`=? LIMIT 1"
	r, err := eq.Query(sql, dbId)
	if err != nil {
		log.LogError("load record PlayerTaskTimeLimit error:", err)
		return err
	}
	defer r.Close()
	if !r.Next() {
		log.LogError("load record PlayerTaskTimeLimit error:", sql, dbId)
		return ErrSqlRowError
	}
	var json []byte
	if err = r.Scan(&json); err != nil {
		log.LogError("load record PlayerTaskTimeLimit error:", err)
		return err
	}

	if json == nil || len(json) < 2 {
		log.LogWarning("load record PlayerTaskTimeLimit error: nil")
		return nil
	}

	err = rec.Unmarshal(json)
	if err != nil {
		log.LogError("unmarshal record PlayerTaskTimeLimit error:", err)
		return err
	}

	return nil
}

func (rec *PlayerTaskTimeLimit) GetName() string {
	return "TaskTimeLimit"
}

//表格的容量
func (rec *PlayerTaskTimeLimit) GetCap() int {
	return rec.MaxRows
}

//表格当前的行数
func (rec *PlayerTaskTimeLimit) GetRows() int {
	return len(rec.Rows)
}

//获取列定义
func (rec *PlayerTaskTimeLimit) ColTypes() ([]int, []string) {
	col := []int{DT_STRING, DT_INT64, DT_INT64}
	cols := []string{"string", "int64", "int64"}
	return col, cols
}

//获取列数
func (rec *PlayerTaskTimeLimit) GetCols() int {
	return rec.Cols
}

//是否要同步到客户端
func (rec *PlayerTaskTimeLimit) IsVisible() bool {
	return true
}

//脏标志
func (rec *PlayerTaskTimeLimit) IsDirty() bool {
	return rec.Dirty
}

func (rec *PlayerTaskTimeLimit) ClearDirty() {
	rec.Dirty = false
}

func (rec *PlayerTaskTimeLimit) SetSyncer(s TableSyncer) {
	rec.syncer = s
}

func (rec *PlayerTaskTimeLimit) GetSyncer() TableSyncer {
	return rec.syncer
}

//序列化
func (rec *PlayerTaskTimeLimit) Serial() ([]byte, error) {
	ar := util.NewStoreArchiver(nil)
	for _, v := range rec.Rows {
		ar.WriteString(v.ID)
		ar.Write(v.StartTime)
		ar.Write(v.EndTime)
	}
	return ar.Data(), nil
}

//序列化一行
func (rec *PlayerTaskTimeLimit) SerialRow(row int) ([]byte, error) {
	if row < 0 || row >= len(rec.Rows) {
		return nil, ErrRowError
	}
	ar := util.NewStoreArchiver(nil)
	v := rec.Rows[row]
	ar.WriteString(v.ID)
	ar.Write(v.StartTime)
	ar.Write(v.EndTime)
	return ar.Data(), nil
}

//通过行列设置值
func (rec *PlayerTaskTimeLimit) Set(row, col int, val interface{}) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskTimeLimit will be overwritten by scenedata")
	}

	if row < 0 || row >= len(rec.Rows) {
		return ErrRowError
	}

	if col < 0 || col >= 3 {
		return ErrColError
	}

	r := &rec.Rows[row]

	switch col {
	case 0:
		val, ok := val.(string)
		if ok {
			r.ID = val
		} else {
			return ErrTypeMismatch
		}
	case 1:
		val, ok := val.(int64)
		if ok {
			r.StartTime = val
		} else {
			return ErrTypeMismatch
		}
	case 2:
		val, ok := val.(int64)
		if ok {
			r.EndTime = val
		} else {
			return ErrTypeMismatch
		}
	}
	if rec.syncer != nil {
		rec.syncer.RecModify(rec.owner, rec, row, col)
	}
	rec.Dirty = true
	return nil
}

//通过行列获取值
func (rec *PlayerTaskTimeLimit) Get(row, col int) (val interface{}, err error) {
	if row < 0 || row >= len(rec.Rows) {
		err = ErrRowError
		return
	}

	if col < 0 || col >= 3 {
		err = ErrColError
		return
	}

	r := rec.Rows[row]

	switch col {
	case 0:
		val = r.ID
	case 1:
		val = r.StartTime
	case 2:
		val = r.EndTime
	}

	return
}

//查找任务编号
func (rec *PlayerTaskTimeLimit) FindID(v string) int {
	for idx, row := range rec.Rows {
		if row.ID == v {
			return idx
		}
	}
	return -1
}

//查找任务编号
func (rec *PlayerTaskTimeLimit) FindNextID(v string, itr int) int {
	itr++
	if itr+1 >= len(rec.Rows) {
		return -1
	}
	for idx, row := range rec.Rows[itr:] {
		if row.ID == v {
			return idx
		}
	}
	return -1
}

//设置任务编号
func (rec *PlayerTaskTimeLimit) SetID(row int, v string) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the ID will be overwritten by scenedata")
	}

	if row < 0 || row >= len(rec.Rows) {
		return ErrRowError
	}

	rec.Rows[row].ID = v
	rec.Dirty = true
	if rec.syncer != nil {
		rec.syncer.RecModify(rec.owner, rec, row, 0)
	}
	return nil
}

//获取任务编号
func (rec *PlayerTaskTimeLimit) GetID(row int) (val string, err error) {
	if row < 0 || row >= len(rec.Rows) {
		err = ErrRowError
		return
	}

	val = rec.Rows[row].ID
	return
}

//查找开始时间记录
func (rec *PlayerTaskTimeLimit) FindStartTime(v int64) int {
	for idx, row := range rec.Rows {
		if row.StartTime == v {
			return idx
		}
	}
	return -1
}

//查找开始时间记录
func (rec *PlayerTaskTimeLimit) FindNextStartTime(v int64, itr int) int {
	itr++
	if itr+1 >= len(rec.Rows) {
		return -1
	}
	for idx, row := range rec.Rows[itr:] {
		if row.StartTime == v {
			return idx
		}
	}
	return -1
}

//设置开始时间记录
func (rec *PlayerTaskTimeLimit) SetStartTime(row int, v int64) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the StartTime will be overwritten by scenedata")
	}

	if row < 0 || row >= len(rec.Rows) {
		return ErrRowError
	}

	rec.Rows[row].StartTime = v
	rec.Dirty = true
	if rec.syncer != nil {
		rec.syncer.RecModify(rec.owner, rec, row, 1)
	}
	return nil
}

//获取开始时间记录
func (rec *PlayerTaskTimeLimit) GetStartTime(row int) (val int64, err error) {
	if row < 0 || row >= len(rec.Rows) {
		err = ErrRowError
		return
	}

	val = rec.Rows[row].StartTime
	return
}

//查找结束时间记录
func (rec *PlayerTaskTimeLimit) FindEndTime(v int64) int {
	for idx, row := range rec.Rows {
		if row.EndTime == v {
			return idx
		}
	}
	return -1
}

//查找结束时间记录
func (rec *PlayerTaskTimeLimit) FindNextEndTime(v int64, itr int) int {
	itr++
	if itr+1 >= len(rec.Rows) {
		return -1
	}
	for idx, row := range rec.Rows[itr:] {
		if row.EndTime == v {
			return idx
		}
	}
	return -1
}

//设置结束时间记录
func (rec *PlayerTaskTimeLimit) SetEndTime(row int, v int64) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the EndTime will be overwritten by scenedata")
	}

	if row < 0 || row >= len(rec.Rows) {
		return ErrRowError
	}

	rec.Rows[row].EndTime = v
	rec.Dirty = true
	if rec.syncer != nil {
		rec.syncer.RecModify(rec.owner, rec, row, 2)
	}
	return nil
}

//获取结束时间记录
func (rec *PlayerTaskTimeLimit) GetEndTime(row int) (val int64, err error) {
	if row < 0 || row >= len(rec.Rows) {
		err = ErrRowError
		return
	}

	val = rec.Rows[row].EndTime
	return
}

//设置一行的值
func (rec *PlayerTaskTimeLimit) SetRow(row int, args ...interface{}) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskTimeLimit will be overwritten by scenedata")
	}

	if _, ok := args[0].(string); !ok {
		return ErrColTypeError
	}
	if _, ok := args[1].(int64); !ok {
		return ErrColTypeError
	}
	if _, ok := args[2].(int64); !ok {
		return ErrColTypeError
	}
	return rec.SetRowValue(row, args[0].(string), args[1].(int64), args[2].(int64))
}

func (rec *PlayerTaskTimeLimit) SetRowInterface(row int, rowvalue interface{}) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskTimeLimit will be overwritten by scenedata")
	}

	if row < 0 || row >= len(rec.Rows) {
		return ErrRowError
	}

	if value, ok := rowvalue.(PlayerTaskTimeLimitRow); ok {
		rec.Rows[row] = value
		if rec.syncer != nil {
			rec.syncer.RecSetRow(rec.owner, rec, row)
		}
		rec.Dirty = true
		return nil
	}

	return ErrColTypeError
}

func (rec *PlayerTaskTimeLimit) SetRowByBytes(row int, rowdata []byte) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskAccepted will be overwritten by scenedata")
	}

	lr := util.NewLoadArchiver(rowdata)

	var id string
	var starttime int64
	var endtime int64

	if err := lr.Read(&id); err != nil {
		return err
	}
	if err := lr.Read(&starttime); err != nil {
		return err
	}
	if err := lr.Read(&endtime); err != nil {
		return err
	}

	return rec.SetRowValue(row, id, starttime, endtime)
}

//设置一行的值
func (rec *PlayerTaskTimeLimit) SetRowValue(row int, id string, starttime int64, endtime int64) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskTimeLimit will be overwritten by scenedata")
	}

	if row < 0 || row >= len(rec.Rows) {
		return ErrRowError
	}

	rec.Rows[row].ID = id
	rec.Rows[row].StartTime = starttime
	rec.Rows[row].EndTime = endtime

	if rec.syncer != nil {
		rec.syncer.RecSetRow(rec.owner, rec, row)
	}
	rec.Dirty = true
	return nil
}

//增加一行,row=-1时,在表格最后面插入一行,否则在row处插入,返回-1插入失败,否则返回插入的行号
func (rec *PlayerTaskTimeLimit) Add(row int, args ...interface{}) int {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskTimeLimit will be overwritten by scenedata")
	}

	if len(args) != rec.Cols {
		return -1
	}

	if _, ok := args[0].(string); !ok {
		return -1
	}
	if _, ok := args[1].(int64); !ok {
		return -1
	}
	if _, ok := args[2].(int64); !ok {
		return -1
	}
	return rec.AddRowValue(row, args[0].(string), args[1].(int64), args[2].(int64))
}

//增加一行,row=-1时,在表格最后面插入一行,否则在row处插入,返回-1插入失败,否则返回插入的行号
func (rec *PlayerTaskTimeLimit) AddByBytes(row int, rowdata []byte) int {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskAccepted will be overwritten by scenedata")
	}

	lr := util.NewLoadArchiver(rowdata)

	var id string
	var starttime int64
	var endtime int64

	if err := lr.Read(&id); err != nil {
		return -1
	}
	if err := lr.Read(&starttime); err != nil {
		return -1
	}
	if err := lr.Read(&endtime); err != nil {
		return -1
	}

	return rec.AddRowValue(row, id, starttime, endtime)
}

//增加一行,row=-1时,在表格最后面插入一行,否则在row处插入,返回-1插入失败,否则返回插入的行号
func (rec *PlayerTaskTimeLimit) AddRow(row int) int {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskTimeLimit will be overwritten by scenedata")
	}
	add := -1

	if len(rec.Rows) >= rec.MaxRows {
		return add
	}

	r := PlayerTaskTimeLimitRow{}

	return rec.AddRowValue(row, r.ID, r.StartTime, r.EndTime)

}

//增加一行,row=-1时,在表格最后面插入一行,否则在row处插入,返回-1插入失败,否则返回插入的行号
func (rec *PlayerTaskTimeLimit) AddRowValue(row int, id string, starttime int64, endtime int64) int {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskTimeLimit will be overwritten by scenedata")
	}

	add := -1

	if len(rec.Rows) >= rec.MaxRows {
		return add
	}

	r := PlayerTaskTimeLimitRow{id, starttime, endtime}

	if row == -1 {
		rec.Rows = append(rec.Rows, r)
		add = len(rec.Rows) - 1
	} else {
		if row >= 0 && row < len(rec.Rows) {
			rec.Rows = append(rec.Rows, PlayerTaskTimeLimitRow{})
			copy(rec.Rows[row+1:], rec.Rows[row:])
			rec.Rows[row] = r
			add = row
		} else {
			rec.Rows = append(rec.Rows, r)
			add = len(rec.Rows) - 1
		}

	}
	if add != -1 {
		if rec.syncer != nil {
			rec.syncer.RecAppend(rec.owner, rec, add)
		}
		rec.Dirty = true
	}
	return add
}

//获取一行数据
func (rec *PlayerTaskTimeLimit) GetRow(row int) (id string, starttime int64, endtime int64, err error) {

	if row < 0 || row >= len(rec.Rows) {
		err = ErrRowError
		return
	}

	r := rec.Rows[row]
	id = r.ID
	starttime = r.StartTime
	endtime = r.EndTime

	return
}

//获取一行数据
func (rec *PlayerTaskTimeLimit) GetRowInterface(row int) (rowvalue interface{}, err error) {

	if row < 0 || row >= len(rec.Rows) {
		err = ErrRowError
		return
	}

	rowvalue = rec.Rows[row]
	return
}

//获取数据
func (rec *PlayerTaskTimeLimit) Scan(row int, id *string, starttime *int64, endtime *int64) bool {

	if row < 0 || row >= len(rec.Rows) {
		return false
	}

	r := rec.Rows[row]
	*id = r.ID
	*starttime = r.StartTime
	*endtime = r.EndTime

	return true
}

//删除一行
func (rec *PlayerTaskTimeLimit) Del(row int) {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskTimeLimit will be overwritten by scenedata")
	}
	if row < 0 || row >= len(rec.Rows) {
		return
	}

	copy(rec.Rows[row:], rec.Rows[row+1:])
	rec.Rows = rec.Rows[:len(rec.Rows)-1]
	rec.Dirty = true

	if rec.syncer != nil {
		rec.syncer.RecDelete(rec.owner, rec, row)
	}
}

//清空表格
func (rec *PlayerTaskTimeLimit) Clear() {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskTimeLimit will be overwritten by scenedata")
	}
	rec.Rows = rec.Rows[:0]
	rec.Dirty = true
	if rec.syncer != nil {
		rec.syncer.RecClear(rec.owner, rec)
	}
}

//是否保存
func (rec *PlayerTaskTimeLimit) IsSave() bool {
	return true
}

//初始化PlayerTaskTimeLimit表
func (obj *Player) initPlayerTaskTimeLimit() {
	obj.TaskTimeLimit_r.MaxRows = 1024
	obj.TaskTimeLimit_r.Cols = 3
	obj.TaskTimeLimit_r.Rows = make([]PlayerTaskTimeLimitRow, 0, 1024)
	obj.TaskTimeLimit_r.owner = obj
}

//获取PlayerTaskTimeLimit表
func (obj *Player) GetPlayerTaskTimeLimit() *PlayerTaskTimeLimit {
	return &obj.TaskTimeLimit_r
}

func (rec *PlayerTaskGlobalRecord) Marshal() ([]byte, error) {
	return json.Marshal(rec)
}

func (rec *PlayerTaskGlobalRecord) Unmarshal(data []byte) error {
	return json.Unmarshal(data, rec)
}

//DB
func (rec *PlayerTaskGlobalRecord) Update(eq ExecQueryer, dbId uint64) error {

	if !rec.Dirty {
		return nil
	}

	data, err := rec.Marshal()
	if err != nil {
		return err
	}
	sql := "UPDATE `tbl_player` SET `r_taskglobalrecord`=? WHERE `id` = ?"

	if _, err := eq.Exec(sql, data, dbId); err != nil {
		log.LogError("update record PlayerTaskGlobalRecord error:", sql, data, dbId)
		return err
	}

	return nil
}

func (rec *PlayerTaskGlobalRecord) Load(eq ExecQueryer, dbId uint64) error {

	rec.Rows = rec.Rows[:0]

	sql := "SELECT `r_taskglobalrecord` FROM `tbl_player` WHERE `id`=? LIMIT 1"
	r, err := eq.Query(sql, dbId)
	if err != nil {
		log.LogError("load record PlayerTaskGlobalRecord error:", err)
		return err
	}
	defer r.Close()
	if !r.Next() {
		log.LogError("load record PlayerTaskGlobalRecord error:", sql, dbId)
		return ErrSqlRowError
	}
	var json []byte
	if err = r.Scan(&json); err != nil {
		log.LogError("load record PlayerTaskGlobalRecord error:", err)
		return err
	}

	if json == nil || len(json) < 2 {
		log.LogWarning("load record PlayerTaskGlobalRecord error: nil")
		return nil
	}

	err = rec.Unmarshal(json)
	if err != nil {
		log.LogError("unmarshal record PlayerTaskGlobalRecord error:", err)
		return err
	}

	return nil
}

func (rec *PlayerTaskGlobalRecord) GetName() string {
	return "TaskGlobalRecord"
}

//表格的容量
func (rec *PlayerTaskGlobalRecord) GetCap() int {
	return rec.MaxRows
}

//表格当前的行数
func (rec *PlayerTaskGlobalRecord) GetRows() int {
	return len(rec.Rows)
}

//获取列定义
func (rec *PlayerTaskGlobalRecord) ColTypes() ([]int, []string) {
	col := []int{DT_INT32, DT_STRING, DT_INT32}
	cols := []string{"int32", "string", "int32"}
	return col, cols
}

//获取列数
func (rec *PlayerTaskGlobalRecord) GetCols() int {
	return rec.Cols
}

//是否要同步到客户端
func (rec *PlayerTaskGlobalRecord) IsVisible() bool {
	return true
}

//脏标志
func (rec *PlayerTaskGlobalRecord) IsDirty() bool {
	return rec.Dirty
}

func (rec *PlayerTaskGlobalRecord) ClearDirty() {
	rec.Dirty = false
}

func (rec *PlayerTaskGlobalRecord) SetSyncer(s TableSyncer) {
	rec.syncer = s
}

func (rec *PlayerTaskGlobalRecord) GetSyncer() TableSyncer {
	return rec.syncer
}

//序列化
func (rec *PlayerTaskGlobalRecord) Serial() ([]byte, error) {
	ar := util.NewStoreArchiver(nil)
	for _, v := range rec.Rows {
		ar.Write(v.Typ)
		ar.WriteString(v.Key)
		ar.Write(v.CurrentAmount)
	}
	return ar.Data(), nil
}

//序列化一行
func (rec *PlayerTaskGlobalRecord) SerialRow(row int) ([]byte, error) {
	if row < 0 || row >= len(rec.Rows) {
		return nil, ErrRowError
	}
	ar := util.NewStoreArchiver(nil)
	v := rec.Rows[row]
	ar.Write(v.Typ)
	ar.WriteString(v.Key)
	ar.Write(v.CurrentAmount)
	return ar.Data(), nil
}

//通过行列设置值
func (rec *PlayerTaskGlobalRecord) Set(row, col int, val interface{}) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskGlobalRecord will be overwritten by scenedata")
	}

	if row < 0 || row >= len(rec.Rows) {
		return ErrRowError
	}

	if col < 0 || col >= 3 {
		return ErrColError
	}

	r := &rec.Rows[row]

	switch col {
	case 0:
		val, ok := val.(int32)
		if ok {
			r.Typ = val
		} else {
			return ErrTypeMismatch
		}
	case 1:
		val, ok := val.(string)
		if ok {
			r.Key = val
		} else {
			return ErrTypeMismatch
		}
	case 2:
		val, ok := val.(int32)
		if ok {
			r.CurrentAmount = val
		} else {
			return ErrTypeMismatch
		}
	}
	if rec.syncer != nil {
		rec.syncer.RecModify(rec.owner, rec, row, col)
	}
	rec.Dirty = true
	return nil
}

//通过行列获取值
func (rec *PlayerTaskGlobalRecord) Get(row, col int) (val interface{}, err error) {
	if row < 0 || row >= len(rec.Rows) {
		err = ErrRowError
		return
	}

	if col < 0 || col >= 3 {
		err = ErrColError
		return
	}

	r := rec.Rows[row]

	switch col {
	case 0:
		val = r.Typ
	case 1:
		val = r.Key
	case 2:
		val = r.CurrentAmount
	}

	return
}

//查找记录类型
func (rec *PlayerTaskGlobalRecord) FindTyp(v int32) int {
	for idx, row := range rec.Rows {
		if row.Typ == v {
			return idx
		}
	}
	return -1
}

//查找记录类型
func (rec *PlayerTaskGlobalRecord) FindNextTyp(v int32, itr int) int {
	itr++
	if itr+1 >= len(rec.Rows) {
		return -1
	}
	for idx, row := range rec.Rows[itr:] {
		if row.Typ == v {
			return idx
		}
	}
	return -1
}

//设置记录类型
func (rec *PlayerTaskGlobalRecord) SetTyp(row int, v int32) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the Typ will be overwritten by scenedata")
	}

	if row < 0 || row >= len(rec.Rows) {
		return ErrRowError
	}

	rec.Rows[row].Typ = v
	rec.Dirty = true
	if rec.syncer != nil {
		rec.syncer.RecModify(rec.owner, rec, row, 0)
	}
	return nil
}

//获取记录类型
func (rec *PlayerTaskGlobalRecord) GetTyp(row int) (val int32, err error) {
	if row < 0 || row >= len(rec.Rows) {
		err = ErrRowError
		return
	}

	val = rec.Rows[row].Typ
	return
}

//查找关键字ID(如物品编号、NPC编号等等)
func (rec *PlayerTaskGlobalRecord) FindKey(v string) int {
	for idx, row := range rec.Rows {
		if row.Key == v {
			return idx
		}
	}
	return -1
}

//查找关键字ID(如物品编号、NPC编号等等)
func (rec *PlayerTaskGlobalRecord) FindNextKey(v string, itr int) int {
	itr++
	if itr+1 >= len(rec.Rows) {
		return -1
	}
	for idx, row := range rec.Rows[itr:] {
		if row.Key == v {
			return idx
		}
	}
	return -1
}

//设置关键字ID(如物品编号、NPC编号等等)
func (rec *PlayerTaskGlobalRecord) SetKey(row int, v string) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the Key will be overwritten by scenedata")
	}

	if row < 0 || row >= len(rec.Rows) {
		return ErrRowError
	}

	rec.Rows[row].Key = v
	rec.Dirty = true
	if rec.syncer != nil {
		rec.syncer.RecModify(rec.owner, rec, row, 1)
	}
	return nil
}

//获取关键字ID(如物品编号、NPC编号等等)
func (rec *PlayerTaskGlobalRecord) GetKey(row int) (val string, err error) {
	if row < 0 || row >= len(rec.Rows) {
		err = ErrRowError
		return
	}

	val = rec.Rows[row].Key
	return
}

//查找当前完成度
func (rec *PlayerTaskGlobalRecord) FindCurrentAmount(v int32) int {
	for idx, row := range rec.Rows {
		if row.CurrentAmount == v {
			return idx
		}
	}
	return -1
}

//查找当前完成度
func (rec *PlayerTaskGlobalRecord) FindNextCurrentAmount(v int32, itr int) int {
	itr++
	if itr+1 >= len(rec.Rows) {
		return -1
	}
	for idx, row := range rec.Rows[itr:] {
		if row.CurrentAmount == v {
			return idx
		}
	}
	return -1
}

//设置当前完成度
func (rec *PlayerTaskGlobalRecord) SetCurrentAmount(row int, v int32) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the CurrentAmount will be overwritten by scenedata")
	}

	if row < 0 || row >= len(rec.Rows) {
		return ErrRowError
	}

	rec.Rows[row].CurrentAmount = v
	rec.Dirty = true
	if rec.syncer != nil {
		rec.syncer.RecModify(rec.owner, rec, row, 2)
	}
	return nil
}

//获取当前完成度
func (rec *PlayerTaskGlobalRecord) GetCurrentAmount(row int) (val int32, err error) {
	if row < 0 || row >= len(rec.Rows) {
		err = ErrRowError
		return
	}

	val = rec.Rows[row].CurrentAmount
	return
}

//设置一行的值
func (rec *PlayerTaskGlobalRecord) SetRow(row int, args ...interface{}) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskGlobalRecord will be overwritten by scenedata")
	}

	if _, ok := args[0].(int32); !ok {
		return ErrColTypeError
	}
	if _, ok := args[1].(string); !ok {
		return ErrColTypeError
	}
	if _, ok := args[2].(int32); !ok {
		return ErrColTypeError
	}
	return rec.SetRowValue(row, args[0].(int32), args[1].(string), args[2].(int32))
}

func (rec *PlayerTaskGlobalRecord) SetRowInterface(row int, rowvalue interface{}) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskGlobalRecord will be overwritten by scenedata")
	}

	if row < 0 || row >= len(rec.Rows) {
		return ErrRowError
	}

	if value, ok := rowvalue.(PlayerTaskGlobalRecordRow); ok {
		rec.Rows[row] = value
		if rec.syncer != nil {
			rec.syncer.RecSetRow(rec.owner, rec, row)
		}
		rec.Dirty = true
		return nil
	}

	return ErrColTypeError
}

func (rec *PlayerTaskGlobalRecord) SetRowByBytes(row int, rowdata []byte) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskAccepted will be overwritten by scenedata")
	}

	lr := util.NewLoadArchiver(rowdata)

	var typ int32
	var key string
	var currentamount int32

	if err := lr.Read(&typ); err != nil {
		return err
	}
	if err := lr.Read(&key); err != nil {
		return err
	}
	if err := lr.Read(&currentamount); err != nil {
		return err
	}

	return rec.SetRowValue(row, typ, key, currentamount)
}

//设置一行的值
func (rec *PlayerTaskGlobalRecord) SetRowValue(row int, typ int32, key string, currentamount int32) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskGlobalRecord will be overwritten by scenedata")
	}

	if row < 0 || row >= len(rec.Rows) {
		return ErrRowError
	}

	rec.Rows[row].Typ = typ
	rec.Rows[row].Key = key
	rec.Rows[row].CurrentAmount = currentamount

	if rec.syncer != nil {
		rec.syncer.RecSetRow(rec.owner, rec, row)
	}
	rec.Dirty = true
	return nil
}

//增加一行,row=-1时,在表格最后面插入一行,否则在row处插入,返回-1插入失败,否则返回插入的行号
func (rec *PlayerTaskGlobalRecord) Add(row int, args ...interface{}) int {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskGlobalRecord will be overwritten by scenedata")
	}

	if len(args) != rec.Cols {
		return -1
	}

	if _, ok := args[0].(int32); !ok {
		return -1
	}
	if _, ok := args[1].(string); !ok {
		return -1
	}
	if _, ok := args[2].(int32); !ok {
		return -1
	}
	return rec.AddRowValue(row, args[0].(int32), args[1].(string), args[2].(int32))
}

//增加一行,row=-1时,在表格最后面插入一行,否则在row处插入,返回-1插入失败,否则返回插入的行号
func (rec *PlayerTaskGlobalRecord) AddByBytes(row int, rowdata []byte) int {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskAccepted will be overwritten by scenedata")
	}

	lr := util.NewLoadArchiver(rowdata)

	var typ int32
	var key string
	var currentamount int32

	if err := lr.Read(&typ); err != nil {
		return -1
	}
	if err := lr.Read(&key); err != nil {
		return -1
	}
	if err := lr.Read(&currentamount); err != nil {
		return -1
	}

	return rec.AddRowValue(row, typ, key, currentamount)
}

//增加一行,row=-1时,在表格最后面插入一行,否则在row处插入,返回-1插入失败,否则返回插入的行号
func (rec *PlayerTaskGlobalRecord) AddRow(row int) int {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskGlobalRecord will be overwritten by scenedata")
	}
	add := -1

	if len(rec.Rows) >= rec.MaxRows {
		return add
	}

	r := PlayerTaskGlobalRecordRow{}

	return rec.AddRowValue(row, r.Typ, r.Key, r.CurrentAmount)

}

//增加一行,row=-1时,在表格最后面插入一行,否则在row处插入,返回-1插入失败,否则返回插入的行号
func (rec *PlayerTaskGlobalRecord) AddRowValue(row int, typ int32, key string, currentamount int32) int {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskGlobalRecord will be overwritten by scenedata")
	}

	add := -1

	if len(rec.Rows) >= rec.MaxRows {
		return add
	}

	r := PlayerTaskGlobalRecordRow{typ, key, currentamount}

	if row == -1 {
		rec.Rows = append(rec.Rows, r)
		add = len(rec.Rows) - 1
	} else {
		if row >= 0 && row < len(rec.Rows) {
			rec.Rows = append(rec.Rows, PlayerTaskGlobalRecordRow{})
			copy(rec.Rows[row+1:], rec.Rows[row:])
			rec.Rows[row] = r
			add = row
		} else {
			rec.Rows = append(rec.Rows, r)
			add = len(rec.Rows) - 1
		}

	}
	if add != -1 {
		if rec.syncer != nil {
			rec.syncer.RecAppend(rec.owner, rec, add)
		}
		rec.Dirty = true
	}
	return add
}

//获取一行数据
func (rec *PlayerTaskGlobalRecord) GetRow(row int) (typ int32, key string, currentamount int32, err error) {

	if row < 0 || row >= len(rec.Rows) {
		err = ErrRowError
		return
	}

	r := rec.Rows[row]
	typ = r.Typ
	key = r.Key
	currentamount = r.CurrentAmount

	return
}

//获取一行数据
func (rec *PlayerTaskGlobalRecord) GetRowInterface(row int) (rowvalue interface{}, err error) {

	if row < 0 || row >= len(rec.Rows) {
		err = ErrRowError
		return
	}

	rowvalue = rec.Rows[row]
	return
}

//获取数据
func (rec *PlayerTaskGlobalRecord) Scan(row int, typ *int32, key *string, currentamount *int32) bool {

	if row < 0 || row >= len(rec.Rows) {
		return false
	}

	r := rec.Rows[row]
	*typ = r.Typ
	*key = r.Key
	*currentamount = r.CurrentAmount

	return true
}

//删除一行
func (rec *PlayerTaskGlobalRecord) Del(row int) {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskGlobalRecord will be overwritten by scenedata")
	}
	if row < 0 || row >= len(rec.Rows) {
		return
	}

	copy(rec.Rows[row:], rec.Rows[row+1:])
	rec.Rows = rec.Rows[:len(rec.Rows)-1]
	rec.Dirty = true

	if rec.syncer != nil {
		rec.syncer.RecDelete(rec.owner, rec, row)
	}
}

//清空表格
func (rec *PlayerTaskGlobalRecord) Clear() {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskGlobalRecord will be overwritten by scenedata")
	}
	rec.Rows = rec.Rows[:0]
	rec.Dirty = true
	if rec.syncer != nil {
		rec.syncer.RecClear(rec.owner, rec)
	}
}

//是否保存
func (rec *PlayerTaskGlobalRecord) IsSave() bool {
	return true
}

//初始化PlayerTaskGlobalRecord表
func (obj *Player) initPlayerTaskGlobalRecord() {
	obj.TaskGlobalRecord_r.MaxRows = 1024
	obj.TaskGlobalRecord_r.Cols = 3
	obj.TaskGlobalRecord_r.Rows = make([]PlayerTaskGlobalRecordRow, 0, 1024)
	obj.TaskGlobalRecord_r.owner = obj
}

//获取PlayerTaskGlobalRecord表
func (obj *Player) GetPlayerTaskGlobalRecord() *PlayerTaskGlobalRecord {
	return &obj.TaskGlobalRecord_r
}

func (rec *PlayerTaskPropRecord) Marshal() ([]byte, error) {
	return json.Marshal(rec)
}

func (rec *PlayerTaskPropRecord) Unmarshal(data []byte) error {
	return json.Unmarshal(data, rec)
}

//DB
func (rec *PlayerTaskPropRecord) Update(eq ExecQueryer, dbId uint64) error {

	if !rec.Dirty {
		return nil
	}

	data, err := rec.Marshal()
	if err != nil {
		return err
	}
	sql := "UPDATE `tbl_player` SET `r_taskproprecord`=? WHERE `id` = ?"

	if _, err := eq.Exec(sql, data, dbId); err != nil {
		log.LogError("update record PlayerTaskPropRecord error:", sql, data, dbId)
		return err
	}

	return nil
}

func (rec *PlayerTaskPropRecord) Load(eq ExecQueryer, dbId uint64) error {

	rec.Rows = rec.Rows[:0]

	sql := "SELECT `r_taskproprecord` FROM `tbl_player` WHERE `id`=? LIMIT 1"
	r, err := eq.Query(sql, dbId)
	if err != nil {
		log.LogError("load record PlayerTaskPropRecord error:", err)
		return err
	}
	defer r.Close()
	if !r.Next() {
		log.LogError("load record PlayerTaskPropRecord error:", sql, dbId)
		return ErrSqlRowError
	}
	var json []byte
	if err = r.Scan(&json); err != nil {
		log.LogError("load record PlayerTaskPropRecord error:", err)
		return err
	}

	if json == nil || len(json) < 2 {
		log.LogWarning("load record PlayerTaskPropRecord error: nil")
		return nil
	}

	err = rec.Unmarshal(json)
	if err != nil {
		log.LogError("unmarshal record PlayerTaskPropRecord error:", err)
		return err
	}

	return nil
}

func (rec *PlayerTaskPropRecord) GetName() string {
	return "TaskPropRecord"
}

//表格的容量
func (rec *PlayerTaskPropRecord) GetCap() int {
	return rec.MaxRows
}

//表格当前的行数
func (rec *PlayerTaskPropRecord) GetRows() int {
	return len(rec.Rows)
}

//获取列定义
func (rec *PlayerTaskPropRecord) ColTypes() ([]int, []string) {
	col := []int{DT_STRING, DT_STRING, DT_STRING}
	cols := []string{"string", "string", "string"}
	return col, cols
}

//获取列数
func (rec *PlayerTaskPropRecord) GetCols() int {
	return rec.Cols
}

//是否要同步到客户端
func (rec *PlayerTaskPropRecord) IsVisible() bool {
	return false
}

//脏标志
func (rec *PlayerTaskPropRecord) IsDirty() bool {
	return rec.Dirty
}

func (rec *PlayerTaskPropRecord) ClearDirty() {
	rec.Dirty = false
}

func (rec *PlayerTaskPropRecord) SetSyncer(s TableSyncer) {
	rec.syncer = s
}

func (rec *PlayerTaskPropRecord) GetSyncer() TableSyncer {
	return rec.syncer
}

//序列化
func (rec *PlayerTaskPropRecord) Serial() ([]byte, error) {
	ar := util.NewStoreArchiver(nil)
	for _, v := range rec.Rows {
		ar.WriteString(v.ID)
		ar.WriteString(v.Property)
		ar.WriteString(v.NeedValue)
	}
	return ar.Data(), nil
}

//序列化一行
func (rec *PlayerTaskPropRecord) SerialRow(row int) ([]byte, error) {
	if row < 0 || row >= len(rec.Rows) {
		return nil, ErrRowError
	}
	ar := util.NewStoreArchiver(nil)
	v := rec.Rows[row]
	ar.WriteString(v.ID)
	ar.WriteString(v.Property)
	ar.WriteString(v.NeedValue)
	return ar.Data(), nil
}

//通过行列设置值
func (rec *PlayerTaskPropRecord) Set(row, col int, val interface{}) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskPropRecord will be overwritten by scenedata")
	}

	if row < 0 || row >= len(rec.Rows) {
		return ErrRowError
	}

	if col < 0 || col >= 3 {
		return ErrColError
	}

	r := &rec.Rows[row]

	switch col {
	case 0:
		val, ok := val.(string)
		if ok {
			r.ID = val
		} else {
			return ErrTypeMismatch
		}
	case 1:
		val, ok := val.(string)
		if ok {
			r.Property = val
		} else {
			return ErrTypeMismatch
		}
	case 2:
		val, ok := val.(string)
		if ok {
			r.NeedValue = val
		} else {
			return ErrTypeMismatch
		}
	}
	if rec.syncer != nil {
		rec.syncer.RecModify(rec.owner, rec, row, col)
	}
	rec.Dirty = true
	return nil
}

//通过行列获取值
func (rec *PlayerTaskPropRecord) Get(row, col int) (val interface{}, err error) {
	if row < 0 || row >= len(rec.Rows) {
		err = ErrRowError
		return
	}

	if col < 0 || col >= 3 {
		err = ErrColError
		return
	}

	r := rec.Rows[row]

	switch col {
	case 0:
		val = r.ID
	case 1:
		val = r.Property
	case 2:
		val = r.NeedValue
	}

	return
}

//查找任务编号
func (rec *PlayerTaskPropRecord) FindID(v string) int {
	for idx, row := range rec.Rows {
		if row.ID == v {
			return idx
		}
	}
	return -1
}

//查找任务编号
func (rec *PlayerTaskPropRecord) FindNextID(v string, itr int) int {
	itr++
	if itr+1 >= len(rec.Rows) {
		return -1
	}
	for idx, row := range rec.Rows[itr:] {
		if row.ID == v {
			return idx
		}
	}
	return -1
}

//设置任务编号
func (rec *PlayerTaskPropRecord) SetID(row int, v string) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the ID will be overwritten by scenedata")
	}

	if row < 0 || row >= len(rec.Rows) {
		return ErrRowError
	}

	rec.Rows[row].ID = v
	rec.Dirty = true
	if rec.syncer != nil {
		rec.syncer.RecModify(rec.owner, rec, row, 0)
	}
	return nil
}

//获取任务编号
func (rec *PlayerTaskPropRecord) GetID(row int) (val string, err error) {
	if row < 0 || row >= len(rec.Rows) {
		err = ErrRowError
		return
	}

	val = rec.Rows[row].ID
	return
}

//查找属性名
func (rec *PlayerTaskPropRecord) FindProperty(v string) int {
	for idx, row := range rec.Rows {
		if row.Property == v {
			return idx
		}
	}
	return -1
}

//查找属性名
func (rec *PlayerTaskPropRecord) FindNextProperty(v string, itr int) int {
	itr++
	if itr+1 >= len(rec.Rows) {
		return -1
	}
	for idx, row := range rec.Rows[itr:] {
		if row.Property == v {
			return idx
		}
	}
	return -1
}

//设置属性名
func (rec *PlayerTaskPropRecord) SetProperty(row int, v string) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the Property will be overwritten by scenedata")
	}

	if row < 0 || row >= len(rec.Rows) {
		return ErrRowError
	}

	rec.Rows[row].Property = v
	rec.Dirty = true
	if rec.syncer != nil {
		rec.syncer.RecModify(rec.owner, rec, row, 1)
	}
	return nil
}

//获取属性名
func (rec *PlayerTaskPropRecord) GetProperty(row int) (val string, err error) {
	if row < 0 || row >= len(rec.Rows) {
		err = ErrRowError
		return
	}

	val = rec.Rows[row].Property
	return
}

//查找属性达成条件
func (rec *PlayerTaskPropRecord) FindNeedValue(v string) int {
	for idx, row := range rec.Rows {
		if row.NeedValue == v {
			return idx
		}
	}
	return -1
}

//查找属性达成条件
func (rec *PlayerTaskPropRecord) FindNextNeedValue(v string, itr int) int {
	itr++
	if itr+1 >= len(rec.Rows) {
		return -1
	}
	for idx, row := range rec.Rows[itr:] {
		if row.NeedValue == v {
			return idx
		}
	}
	return -1
}

//设置属性达成条件
func (rec *PlayerTaskPropRecord) SetNeedValue(row int, v string) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the NeedValue will be overwritten by scenedata")
	}

	if row < 0 || row >= len(rec.Rows) {
		return ErrRowError
	}

	rec.Rows[row].NeedValue = v
	rec.Dirty = true
	if rec.syncer != nil {
		rec.syncer.RecModify(rec.owner, rec, row, 2)
	}
	return nil
}

//获取属性达成条件
func (rec *PlayerTaskPropRecord) GetNeedValue(row int) (val string, err error) {
	if row < 0 || row >= len(rec.Rows) {
		err = ErrRowError
		return
	}

	val = rec.Rows[row].NeedValue
	return
}

//设置一行的值
func (rec *PlayerTaskPropRecord) SetRow(row int, args ...interface{}) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskPropRecord will be overwritten by scenedata")
	}

	if _, ok := args[0].(string); !ok {
		return ErrColTypeError
	}
	if _, ok := args[1].(string); !ok {
		return ErrColTypeError
	}
	if _, ok := args[2].(string); !ok {
		return ErrColTypeError
	}
	return rec.SetRowValue(row, args[0].(string), args[1].(string), args[2].(string))
}

func (rec *PlayerTaskPropRecord) SetRowInterface(row int, rowvalue interface{}) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskPropRecord will be overwritten by scenedata")
	}

	if row < 0 || row >= len(rec.Rows) {
		return ErrRowError
	}

	if value, ok := rowvalue.(PlayerTaskPropRecordRow); ok {
		rec.Rows[row] = value
		if rec.syncer != nil {
			rec.syncer.RecSetRow(rec.owner, rec, row)
		}
		rec.Dirty = true
		return nil
	}

	return ErrColTypeError
}

func (rec *PlayerTaskPropRecord) SetRowByBytes(row int, rowdata []byte) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskAccepted will be overwritten by scenedata")
	}

	lr := util.NewLoadArchiver(rowdata)

	var id string
	var property string
	var needvalue string

	if err := lr.Read(&id); err != nil {
		return err
	}
	if err := lr.Read(&property); err != nil {
		return err
	}
	if err := lr.Read(&needvalue); err != nil {
		return err
	}

	return rec.SetRowValue(row, id, property, needvalue)
}

//设置一行的值
func (rec *PlayerTaskPropRecord) SetRowValue(row int, id string, property string, needvalue string) error {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskPropRecord will be overwritten by scenedata")
	}

	if row < 0 || row >= len(rec.Rows) {
		return ErrRowError
	}

	rec.Rows[row].ID = id
	rec.Rows[row].Property = property
	rec.Rows[row].NeedValue = needvalue

	if rec.syncer != nil {
		rec.syncer.RecSetRow(rec.owner, rec, row)
	}
	rec.Dirty = true
	return nil
}

//增加一行,row=-1时,在表格最后面插入一行,否则在row处插入,返回-1插入失败,否则返回插入的行号
func (rec *PlayerTaskPropRecord) Add(row int, args ...interface{}) int {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskPropRecord will be overwritten by scenedata")
	}

	if len(args) != rec.Cols {
		return -1
	}

	if _, ok := args[0].(string); !ok {
		return -1
	}
	if _, ok := args[1].(string); !ok {
		return -1
	}
	if _, ok := args[2].(string); !ok {
		return -1
	}
	return rec.AddRowValue(row, args[0].(string), args[1].(string), args[2].(string))
}

//增加一行,row=-1时,在表格最后面插入一行,否则在row处插入,返回-1插入失败,否则返回插入的行号
func (rec *PlayerTaskPropRecord) AddByBytes(row int, rowdata []byte) int {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskAccepted will be overwritten by scenedata")
	}

	lr := util.NewLoadArchiver(rowdata)

	var id string
	var property string
	var needvalue string

	if err := lr.Read(&id); err != nil {
		return -1
	}
	if err := lr.Read(&property); err != nil {
		return -1
	}
	if err := lr.Read(&needvalue); err != nil {
		return -1
	}

	return rec.AddRowValue(row, id, property, needvalue)
}

//增加一行,row=-1时,在表格最后面插入一行,否则在row处插入,返回-1插入失败,否则返回插入的行号
func (rec *PlayerTaskPropRecord) AddRow(row int) int {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskPropRecord will be overwritten by scenedata")
	}
	add := -1

	if len(rec.Rows) >= rec.MaxRows {
		return add
	}

	r := PlayerTaskPropRecordRow{}

	return rec.AddRowValue(row, r.ID, r.Property, r.NeedValue)

}

//增加一行,row=-1时,在表格最后面插入一行,否则在row处插入,返回-1插入失败,否则返回插入的行号
func (rec *PlayerTaskPropRecord) AddRowValue(row int, id string, property string, needvalue string) int {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskPropRecord will be overwritten by scenedata")
	}

	add := -1

	if len(rec.Rows) >= rec.MaxRows {
		return add
	}

	r := PlayerTaskPropRecordRow{id, property, needvalue}

	if row == -1 {
		rec.Rows = append(rec.Rows, r)
		add = len(rec.Rows) - 1
	} else {
		if row >= 0 && row < len(rec.Rows) {
			rec.Rows = append(rec.Rows, PlayerTaskPropRecordRow{})
			copy(rec.Rows[row+1:], rec.Rows[row:])
			rec.Rows[row] = r
			add = row
		} else {
			rec.Rows = append(rec.Rows, r)
			add = len(rec.Rows) - 1
		}

	}
	if add != -1 {
		if rec.syncer != nil {
			rec.syncer.RecAppend(rec.owner, rec, add)
		}
		rec.Dirty = true
	}
	return add
}

//获取一行数据
func (rec *PlayerTaskPropRecord) GetRow(row int) (id string, property string, needvalue string, err error) {

	if row < 0 || row >= len(rec.Rows) {
		err = ErrRowError
		return
	}

	r := rec.Rows[row]
	id = r.ID
	property = r.Property
	needvalue = r.NeedValue

	return
}

//获取一行数据
func (rec *PlayerTaskPropRecord) GetRowInterface(row int) (rowvalue interface{}, err error) {

	if row < 0 || row >= len(rec.Rows) {
		err = ErrRowError
		return
	}

	rowvalue = rec.Rows[row]
	return
}

//获取数据
func (rec *PlayerTaskPropRecord) Scan(row int, id *string, property *string, needvalue *string) bool {

	if row < 0 || row >= len(rec.Rows) {
		return false
	}

	r := rec.Rows[row]
	*id = r.ID
	*property = r.Property
	*needvalue = r.NeedValue

	return true
}

//删除一行
func (rec *PlayerTaskPropRecord) Del(row int) {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskPropRecord will be overwritten by scenedata")
	}
	if row < 0 || row >= len(rec.Rows) {
		return
	}

	copy(rec.Rows[row:], rec.Rows[row+1:])
	rec.Rows = rec.Rows[:len(rec.Rows)-1]
	rec.Dirty = true

	if rec.syncer != nil {
		rec.syncer.RecDelete(rec.owner, rec, row)
	}
}

//清空表格
func (rec *PlayerTaskPropRecord) Clear() {
	if rec.owner.InBase && rec.owner.InScene { //当玩家在场景中时，在base中修改scenedata，在同步时会被覆盖.
		log.LogError("the TaskPropRecord will be overwritten by scenedata")
	}
	rec.Rows = rec.Rows[:0]
	rec.Dirty = true
	if rec.syncer != nil {
		rec.syncer.RecClear(rec.owner, rec)
	}
}

//是否保存
func (rec *PlayerTaskPropRecord) IsSave() bool {
	return true
}

//初始化PlayerTaskPropRecord表
func (obj *Player) initPlayerTaskPropRecord() {
	obj.TaskPropRecord_r.MaxRows = 1024
	obj.TaskPropRecord_r.Cols = 3
	obj.TaskPropRecord_r.Rows = make([]PlayerTaskPropRecordRow, 0, 1024)
	obj.TaskPropRecord_r.owner = obj
}

//获取PlayerTaskPropRecord表
func (obj *Player) GetPlayerTaskPropRecord() *PlayerTaskPropRecord {
	return &obj.TaskPropRecord_r
}

//初始化所有的表格
func (obj *Player) initRec() {

	obj.initPlayerMailBox()
	obj.initPlayerTaskAccepted()
	obj.initPlayerTaskRecord()
	obj.initPlayerTaskCanAccept()
	obj.initPlayerTaskTimeLimit()
	obj.initPlayerTaskGlobalRecord()
	obj.initPlayerTaskPropRecord()
}

//获取某个表格
func (obj *Player) GetRec(rec string) Recorder {
	switch rec {
	case "MailBox":
		return &obj.MailBox_r
	case "TaskAccepted":
		return &obj.TaskAccepted_r
	case "TaskRecord":
		return &obj.TaskRecord_r
	case "TaskCanAccept":
		return &obj.TaskCanAccept_r
	case "TaskTimeLimit":
		return &obj.TaskTimeLimit_r
	case "TaskGlobalRecord":
		return &obj.TaskGlobalRecord_r
	case "TaskPropRecord":
		return &obj.TaskPropRecord_r
	default:
		return nil
	}
}

//获取所有表格名称
func (obj *Player) GetRecNames() []string {
	return []string{"MailBox", "TaskAccepted", "TaskRecord", "TaskCanAccept", "TaskTimeLimit", "TaskGlobalRecord", "TaskPropRecord"}
}

func (obj *Player) PlayerInit() {
	obj.quiting = false
	obj.Save = true
	obj.ObjectType = PLAYER
	obj.InBase = false
	obj.InScene = false
	obj.uid = 0
}

//重置
func (obj *Player) Reset() {

	obj.Moveable.Clear()
	obj.AOI.Clear()
	//属性初始化
	obj.Player_t = Player_t{}
	obj.Player_Save.Player_Save_Property = Player_Save_Property{}
	obj.Player_Propertys = Player_Propertys{}
	obj.PlayerInit()
	//表格初始化
	obj.MailBox_r.Clear()
	obj.MailBox_r.syncer = nil
	obj.TaskAccepted_r.Clear()
	obj.TaskAccepted_r.syncer = nil
	obj.TaskRecord_r.Clear()
	obj.TaskRecord_r.syncer = nil
	obj.TaskCanAccept_r.Clear()
	obj.TaskCanAccept_r.syncer = nil
	obj.TaskTimeLimit_r.Clear()
	obj.TaskTimeLimit_r.syncer = nil
	obj.TaskGlobalRecord_r.Clear()
	obj.TaskGlobalRecord_r.syncer = nil
	obj.TaskPropRecord_r.Clear()
	obj.TaskPropRecord_r.syncer = nil

	obj.ClearDirty()
	obj.ClearModify()
	obj.ClearExtraData()
	for k := range obj.propcritical {
		obj.propcritical[k] = 0
		obj.propflag[k] = 0
	}

}

//对象拷贝
func (obj *Player) Copy(other Entity) error {
	if t, ok := other.(*Player); ok {
		//属性复制
		obj.DbId = t.DbId
		obj.NameHash = t.NameHash
		obj.IDHash = t.IDHash
		obj.uid = t.uid

		*obj.Moveable = *t.Moveable
		*obj.AOI = *t.AOI
		obj.Player_t = t.Player_t
		obj.Player_Save.Player_Save_Property = t.Player_Save_Property
		obj.Player_Propertys = t.Player_Propertys

		var l int
		//表格复制
		obj.MailBox_r.Clear()
		l = len(t.MailBox_r.Rows)
		for i := 0; i < l; i++ {
			obj.MailBox_r.AddRowValue(-1, t.MailBox_r.Rows[i].Source_uid, t.MailBox_r.Rows[i].Source_name, t.MailBox_r.Rows[i].SendTime, t.MailBox_r.Rows[i].Title, t.MailBox_r.Rows[i].Content, t.MailBox_r.Rows[i].Appendix, t.MailBox_r.Rows[i].IsRead, t.MailBox_r.Rows[i].Serial_no, t.MailBox_r.Rows[i].MsgType)
		}

		obj.TaskAccepted_r.Clear()
		l = len(t.TaskAccepted_r.Rows)
		for i := 0; i < l; i++ {
			obj.TaskAccepted_r.AddRowValue(-1, t.TaskAccepted_r.Rows[i].ID, t.TaskAccepted_r.Rows[i].Flag)
		}

		obj.TaskRecord_r.Clear()
		l = len(t.TaskRecord_r.Rows)
		for i := 0; i < l; i++ {
			obj.TaskRecord_r.AddRowValue(-1, t.TaskRecord_r.Rows[i].ID, t.TaskRecord_r.Rows[i].Typ, t.TaskRecord_r.Rows[i].Key, t.TaskRecord_r.Rows[i].CurrentAmount, t.TaskRecord_r.Rows[i].TotalAmount, t.TaskRecord_r.Rows[i].Flag)
		}

		obj.TaskCanAccept_r.Clear()
		l = len(t.TaskCanAccept_r.Rows)
		for i := 0; i < l; i++ {
			obj.TaskCanAccept_r.AddRowValue(-1, t.TaskCanAccept_r.Rows[i].ID)
		}

		obj.TaskTimeLimit_r.Clear()
		l = len(t.TaskTimeLimit_r.Rows)
		for i := 0; i < l; i++ {
			obj.TaskTimeLimit_r.AddRowValue(-1, t.TaskTimeLimit_r.Rows[i].ID, t.TaskTimeLimit_r.Rows[i].StartTime, t.TaskTimeLimit_r.Rows[i].EndTime)
		}

		obj.TaskGlobalRecord_r.Clear()
		l = len(t.TaskGlobalRecord_r.Rows)
		for i := 0; i < l; i++ {
			obj.TaskGlobalRecord_r.AddRowValue(-1, t.TaskGlobalRecord_r.Rows[i].Typ, t.TaskGlobalRecord_r.Rows[i].Key, t.TaskGlobalRecord_r.Rows[i].CurrentAmount)
		}

		obj.TaskPropRecord_r.Clear()
		l = len(t.TaskPropRecord_r.Rows)
		for i := 0; i < l; i++ {
			obj.TaskPropRecord_r.AddRowValue(-1, t.TaskPropRecord_r.Rows[i].ID, t.TaskPropRecord_r.Rows[i].Property, t.TaskPropRecord_r.Rows[i].NeedValue)
		}

		return nil
	}

	return ErrCopyObjError
}

//DB相关
//同步到数据库
func (obj *Player) SyncToDb() {

}

//从data中取出configid
func (obj *Player) GetConfigFromDb(data interface{}) string {
	if v, ok := data.(*Player_Save); ok {
		return v.ConfigId
	}

	return ""
}

//从数据库恢复
func (obj *Player) SyncFromDb(data interface{}) bool {
	if v, ok := data.(*Player_Save); ok {
		obj.Player_Save.Player_Save_Property = v.Player_Save_Property

		obj.MailBox_r.Clear()
		if l := len(v.MailBox_r.Rows); l > 0 {
			for i := 0; i < l; i++ {
				obj.MailBox_r.AddRowValue(-1, v.MailBox_r.Rows[i].Source_uid, v.MailBox_r.Rows[i].Source_name, v.MailBox_r.Rows[i].SendTime, v.MailBox_r.Rows[i].Title, v.MailBox_r.Rows[i].Content, v.MailBox_r.Rows[i].Appendix, v.MailBox_r.Rows[i].IsRead, v.MailBox_r.Rows[i].Serial_no, v.MailBox_r.Rows[i].MsgType)
			}
		}

		obj.TaskAccepted_r.Clear()
		if l := len(v.TaskAccepted_r.Rows); l > 0 {
			for i := 0; i < l; i++ {
				obj.TaskAccepted_r.AddRowValue(-1, v.TaskAccepted_r.Rows[i].ID, v.TaskAccepted_r.Rows[i].Flag)
			}
		}

		obj.TaskRecord_r.Clear()
		if l := len(v.TaskRecord_r.Rows); l > 0 {
			for i := 0; i < l; i++ {
				obj.TaskRecord_r.AddRowValue(-1, v.TaskRecord_r.Rows[i].ID, v.TaskRecord_r.Rows[i].Typ, v.TaskRecord_r.Rows[i].Key, v.TaskRecord_r.Rows[i].CurrentAmount, v.TaskRecord_r.Rows[i].TotalAmount, v.TaskRecord_r.Rows[i].Flag)
			}
		}

		obj.TaskCanAccept_r.Clear()
		if l := len(v.TaskCanAccept_r.Rows); l > 0 {
			for i := 0; i < l; i++ {
				obj.TaskCanAccept_r.AddRowValue(-1, v.TaskCanAccept_r.Rows[i].ID)
			}
		}

		obj.TaskTimeLimit_r.Clear()
		if l := len(v.TaskTimeLimit_r.Rows); l > 0 {
			for i := 0; i < l; i++ {
				obj.TaskTimeLimit_r.AddRowValue(-1, v.TaskTimeLimit_r.Rows[i].ID, v.TaskTimeLimit_r.Rows[i].StartTime, v.TaskTimeLimit_r.Rows[i].EndTime)
			}
		}

		obj.TaskGlobalRecord_r.Clear()
		if l := len(v.TaskGlobalRecord_r.Rows); l > 0 {
			for i := 0; i < l; i++ {
				obj.TaskGlobalRecord_r.AddRowValue(-1, v.TaskGlobalRecord_r.Rows[i].Typ, v.TaskGlobalRecord_r.Rows[i].Key, v.TaskGlobalRecord_r.Rows[i].CurrentAmount)
			}
		}

		obj.TaskPropRecord_r.Clear()
		if l := len(v.TaskPropRecord_r.Rows); l > 0 {
			for i := 0; i < l; i++ {
				obj.TaskPropRecord_r.AddRowValue(-1, v.TaskPropRecord_r.Rows[i].ID, v.TaskPropRecord_r.Rows[i].Property, v.TaskPropRecord_r.Rows[i].NeedValue)
			}
		}

		obj.NameHash = Hash(obj.Name)
		obj.IDHash = Hash(obj.ConfigId)
		return true
	}

	return false
}

func (obj *Player) GetSaveLoader() DBSaveLoader {
	return &obj.Player_Save
}

func (obj *Player) GobEncode() ([]byte, error) {
	w := new(bytes.Buffer)
	encoder := gob.NewEncoder(w)
	var err error

	err = encoder.Encode(obj.uid)
	if err != nil {
		return nil, err
	}
	err = encoder.Encode(obj.Save)
	if err != nil {
		return nil, err
	}
	err = encoder.Encode(obj.DbId)
	if err != nil {
		return nil, err
	}
	err = encoder.Encode(obj.NameHash)
	if err != nil {
		return nil, err
	}
	err = encoder.Encode(obj.IDHash)
	if err != nil {
		return nil, err
	}
	err = encoder.Encode(obj.Index)
	if err != nil {
		return nil, err
	}

	err = encoder.Encode(obj.Moveable)
	if err != nil {
		return nil, err
	}
	err = encoder.Encode(obj.AOI)
	if err != nil {
		return nil, err
	}
	err = encoder.Encode(obj.Player_Save)
	if err != nil {
		return nil, err
	}
	err = encoder.Encode(obj.Player_Propertys)
	if err != nil {
		return nil, err
	}

	return w.Bytes(), nil
}

func (obj *Player) GobDecode(buf []byte) error {
	r := bytes.NewBuffer(buf)
	decoder := gob.NewDecoder(r)
	var err error

	err = decoder.Decode(&obj.uid)
	if err != nil {
		return err
	}
	err = decoder.Decode(&obj.Save)
	if err != nil {
		return err
	}
	err = decoder.Decode(&obj.DbId)
	if err != nil {
		return err
	}
	err = decoder.Decode(&obj.NameHash)
	if err != nil {
		return err
	}
	err = decoder.Decode(&obj.IDHash)
	if err != nil {
		return err
	}
	err = decoder.Decode(&obj.Index)
	if err != nil {
		return err
	}

	err = decoder.Decode(obj.Moveable)
	if err != nil {
		return err
	}
	err = decoder.Decode(obj.AOI)
	if err != nil {
		return err
	}
	err = decoder.Decode(&obj.Player_Save)
	if err != nil {
		return err
	}
	err = decoder.Decode(&obj.Player_Propertys)
	if err != nil {
		return err
	}

	return nil
}

//由子类调用的初始化函数
func (obj *Player) baseInit(dirty, modify, extra map[string]interface{}) {
	//初始化表格
	obj.initRec()
	obj.Mdirty = dirty
	obj.Mmodify = modify
	obj.ExtraData = extra
}

func (obj *Player) Serial() ([]byte, error) {
	ar := util.NewStoreArchiver(nil)
	ps := obj.GetVisiblePropertys(0)
	ar.Write(int16(len(ps)))

	ar.Write(int16(1))
	ar.Write(obj.Name)
	ar.Write(int16(2))
	ar.Write(obj.Sex)
	ar.Write(int16(3))
	ar.Write(obj.Level)
	ar.Write(int16(4))
	ar.Write(obj.Model)
	ar.Write(int16(5))
	ar.Write(obj.Exp)
	ar.Write(int16(6))
	ar.Write(obj.Vip)
	ar.Write(int16(7))
	ar.Write(obj.MaxExp)
	ar.Write(int16(8))
	ar.Write(obj.HP)
	ar.Write(int16(9))
	ar.Write(obj.MP)
	ar.Write(int16(10))
	ar.Write(obj.MaxHP)
	ar.Write(int16(11))
	ar.Write(obj.MaxMP)
	return ar.Data(), nil
}

func (obj *Player) SerialModify() ([]byte, error) {
	if len(obj.Mmodify) == 0 {
		return nil, nil
	}
	ar := util.NewStoreArchiver(nil)
	ar.Write(int16(len(obj.Mmodify)))
	for k, v := range obj.Mmodify {
		if !obj.PropertyIsPrivate(k) {
			continue
		}
		idx, _ := obj.GetPropertyIndex(k)

		ar.Write(int16(idx))
		ar.Write(v)
	}

	return ar.Data(), nil
}

func (obj *Player) IsSceneData(prop string) bool {
	idx, err := obj.GetPropertyIndex(prop)
	if err != nil {
		return false
	}

	return IsPlayerSceneData(idx)
}

//通过scenedata同步
func (obj *Player) SyncFromSceneData(val interface{}) error {
	var sd *PlayerSceneData
	var ok bool
	if sd, ok = val.(*PlayerSceneData); !ok {
		return fmt.Errorf("type not PlayerSceneData", sd)
	}

	if obj.HP != sd.HP {
		obj.HP = sd.HP //血
		obj.setDirty("HP", obj.HP)
	}
	if obj.MP != sd.MP {
		obj.MP = sd.MP //魔
		obj.setDirty("MP", obj.MP)
	}

	if sd.MailBox_r.Dirty {
		obj.MailBox_r.Rows = obj.MailBox_r.Rows[:0]
		obj.MailBox_r.Rows = append(obj.MailBox_r.Rows, sd.MailBox_r.Rows...) //邮箱
		obj.MailBox_r.Dirty = true
	}
	if sd.TaskAccepted_r.Dirty {
		obj.TaskAccepted_r.Rows = obj.TaskAccepted_r.Rows[:0]
		obj.TaskAccepted_r.Rows = append(obj.TaskAccepted_r.Rows, sd.TaskAccepted_r.Rows...) //已承接任务表
		obj.TaskAccepted_r.Dirty = true
	}
	if sd.TaskRecord_r.Dirty {
		obj.TaskRecord_r.Rows = obj.TaskRecord_r.Rows[:0]
		obj.TaskRecord_r.Rows = append(obj.TaskRecord_r.Rows, sd.TaskRecord_r.Rows...) //任务记录表
		obj.TaskRecord_r.Dirty = true
	}
	if sd.TaskCanAccept_r.Dirty {
		obj.TaskCanAccept_r.Rows = obj.TaskCanAccept_r.Rows[:0]
		obj.TaskCanAccept_r.Rows = append(obj.TaskCanAccept_r.Rows, sd.TaskCanAccept_r.Rows...) //可承接任务表
		obj.TaskCanAccept_r.Dirty = true
	}
	if sd.TaskTimeLimit_r.Dirty {
		obj.TaskTimeLimit_r.Rows = obj.TaskTimeLimit_r.Rows[:0]
		obj.TaskTimeLimit_r.Rows = append(obj.TaskTimeLimit_r.Rows, sd.TaskTimeLimit_r.Rows...) //任务时间限制记录表
		obj.TaskTimeLimit_r.Dirty = true
	}
	if sd.TaskGlobalRecord_r.Dirty {
		obj.TaskGlobalRecord_r.Rows = obj.TaskGlobalRecord_r.Rows[:0]
		obj.TaskGlobalRecord_r.Rows = append(obj.TaskGlobalRecord_r.Rows, sd.TaskGlobalRecord_r.Rows...) //任务全局记录表
		obj.TaskGlobalRecord_r.Dirty = true
	}
	if sd.TaskPropRecord_r.Dirty {
		obj.TaskPropRecord_r.Rows = obj.TaskPropRecord_r.Rows[:0]
		obj.TaskPropRecord_r.Rows = append(obj.TaskPropRecord_r.Rows, sd.TaskPropRecord_r.Rows...) //任务属性记录表
		obj.TaskPropRecord_r.Dirty = true
	}

	return nil
}

func (obj *Player) GetSceneData() interface{} {
	sd := &PlayerSceneData{}

	//属性
	sd.HP = obj.HP //血
	sd.MP = obj.MP //魔

	//表格
	sd.MailBox_r = obj.MailBox_r
	sd.TaskAccepted_r = obj.TaskAccepted_r
	sd.TaskRecord_r = obj.TaskRecord_r
	sd.TaskCanAccept_r = obj.TaskCanAccept_r
	sd.TaskTimeLimit_r = obj.TaskTimeLimit_r
	sd.TaskGlobalRecord_r = obj.TaskGlobalRecord_r
	sd.TaskPropRecord_r = obj.TaskPropRecord_r
	return sd
}

//创建函数
func CreatePlayer() *Player {
	obj := &Player{}

	obj.Moveable = &Moveable{}
	obj.Moveable.Init()
	obj.AOI = &AOI{}
	obj.AOI.Init()
	obj.ObjectType = PLAYER
	obj.initRec()

	obj.propcritical = make([]uint64, int(math.Ceil(float64(13)/64)))
	obj.propflag = make([]uint64, int(math.Ceil(float64(13)/64)))
	obj.PlayerInit()

	obj.Mdirty = make(map[string]interface{}, 32)
	obj.Mmodify = make(map[string]interface{}, 32)
	obj.ExtraData = make(map[string]interface{}, 16)

	return obj
}

type PlayerSceneData struct {
	HP int32 //血
	MP int32 //魔

	MailBox_r          PlayerMailBox          //邮箱
	TaskAccepted_r     PlayerTaskAccepted     //已承接任务表
	TaskRecord_r       PlayerTaskRecord       //任务记录表
	TaskCanAccept_r    PlayerTaskCanAccept    //可承接任务表
	TaskTimeLimit_r    PlayerTaskTimeLimit    //任务时间限制记录表
	TaskGlobalRecord_r PlayerTaskGlobalRecord //任务全局记录表
	TaskPropRecord_r   PlayerTaskPropRecord   //任务属性记录表
}

func IsPlayerSceneData(idx int) bool {
	switch idx {
	case 0: //数据版本号
		return false
	case 1: //名称
		return false
	case 2: //性别
		return false
	case 3: //等级
		return false
	case 4: //模型
		return false
	case 5: //经验
		return false
	case 6: //VIP等级
		return false
	case 7: //经验上限
		return false
	case 8: //血
		return true
	case 9: //魔
		return true
	case 10: //血上限
		return false
	case 11: //魔上限
		return false
	case 12: //最后刷新时间
		return false
	}
	return false
}

func PlayerInit() {
	gob.Register(&Player_Save{})
	gob.Register(&Player{})
	gob.Register(&PlayerSceneData{})
}
